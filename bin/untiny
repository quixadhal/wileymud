#!/usr/bin/perl -w

use utf8;
use strict;
#use open ":encoding(utf8)";
#binmode STDERR, ":encoding(utf8)";
#binmode STDOUT, ":encoding(utf8)";
use Time::HiRes qw(sleep time alarm);
use POSIX qw(strftime);
use Encode qw(encode encode_utf8);
no warnings 'utf8';
use English qw( âˆ’no_match_vars );
use Data::Dumper;
use HTTP::Request::Common qw(POST);
use HTML::Entities;
use LWP::UserAgent;
use URI;
use WWW::Shorten::TinyURL qw(makeashorterlink);
#use WWW::Shorten::Bitly;
#Bitly has adopted a new API and no longer accepts the one this CPAN module uses
use DBI;
use JSON;

my $DB_NAME = 'i3log';
my $DB_FILE = '/home/wiley/lib/i3/wiley.db';
my $LPC_DUMP_FILE = '/home/wiley/lib/i3/urldb.lpc-saved-object';
my $GOOGLE_API_KEY_FILE = '/home/wiley/.google-api.key';
my $BITLY_API_KEY_FILE = '/home/wiley/.bitly-api.key';
my $api_key = undef;
my $db = undef;
my $sqlite_db = undef;
my $result = undef;
my $update_sql = undef;

my $prog = $0;
my $url = undef;
my $do_sql = undef;
my $do_debug = undef;
my $do_checksum = undef;
my $do_lpc = undef;
my $do_transfer = undef;
my $do_cache = undef;
my $do_add = undef;
my $channel = undef;
my $speaker = undef;
my $style = undef;

my $RESET   = undef;
my $YELLOW  = undef;
my $RED     = undef;
my $GREEN   = undef;
my $CYAN    = undef;
my $WHITE   = undef;
my $FLASH   = undef;

my $timeout = 15;
my $lwp = LWP::UserAgent->new( cookie_jar => {} );
   $lwp->timeout($timeout);
   $lwp->agent('User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36');
   $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
   $URI::ABS_REMOTE_LEADING_DOTS = 1; 
   $lwp->max_redirect(5);

my @cr3tab =
(   # CRC polynomial 0xedb88320
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd,
    0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb,
    0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447,
    0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75,
    0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11,
    0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
    0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b,
    0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49,
    0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
    0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3,
    0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af,
    0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d,
    0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9,
    0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767,
    0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703,
    0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
    0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d,
    0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b,
    0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
    0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5,
    0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1,
    0x5a05df1b, 0x2d02ef8d
);

sub crc32 {
    my $buf = shift;
    my $len = shift;

    my $result = 0xFFFFFFFF;

    return $result if !defined $buf or $len < 1;

    #define UPDC32(b, c) (cr3tab[(c ^ b) & 0xff] ^ ((c >> 8) & 0x00FFFFFF))
    #while(len--) {
    #    result = UPDC32((u_int32_t) *buf++, result);
    #}

    $buf .= "\0\0\0"; # Simplify our life a bit.
    for( my $i = 0; $i < $len; $i++ ) {
        my $cc = $result;
        my $bb = unpack("L", substr($buf, $i, 4));
        my $bbc = substr($buf, $i, 1);

        my $ccbb = ($cc ^ $bb) & 0xFF;
        my $cceight = ($cc >> 8);

        my $lookup = $cr3tab[$ccbb];
        my $masked = $cceight & 0x00FFFFFF;
        my $res = $lookup ^ $masked;

        #printf "%d - '%s': cr3tab[(%08x ^ %08x) & 0xFF] ^ ((%08x >> 8) & 0x00FFFFFF)\n", $i, $bbc, $cc, $bb, $cc;
        #printf "%d - '%s': cr3tab[%02x] ^ (%08x & 0x00FFFFFF)\n", $i, $bbc, $ccbb, $cceight;
        #printf "%d - '%s': %08x ^ %08x\n", $i, $bbc, $lookup, $masked;
        #printf "%d - '%s': %08x\n", $i, $bbc, $res;

        $result = $res;
    }
    return $result;
}

sub timestamp {
    my $now = time();
    my $fraction = substr(sprintf("%3.3f", $now - (int $now)), 1);

    my $stamp = strftime("%Y-%m-%d %H:%M:%S", localtime($now));
    return sprintf("%s%s -- ", $stamp, $fraction);
}

sub channel_color {
    my $channel = shift;
    my $colors = {
        "intermud"      => "%^WHITE%^",
        "muds"          => "%^WHITE%^",
        "connections"   => "%^BOLD%^%^WHITE%^",
        "death"         => "%^BOLD%^%^RED%^",
        "cre"           => "%^BOLD%^%^GREEN%^",
        "admin"         => "%^BOLD%^%^MAGENTA%^",
        "newbie"        => "%^B_YELLOW%^%^BLACK%^",
        "gossip"        => "%^B_BLUE%^%^YELLOW%^",

        "wiley"         => "%^BOLD%^%^YELLOW%^",
        "ds"            => "%^BOLD%^%^YELLOW%^",
        "dchat"         => "%^CYAN%^",
        "intergossip"   => "%^GREEN%^",
        "intercre"      => "%^ORANGE%^",
        "pyom"          => "%^FLASH%^%^BOLD%^%^GREEN%^",
        "free_speech"   => "%^BOLD%^%^RED%^",
        "url"           => "%^BOLD%^%^WHITE%^",
        "discord"       => "%^BOLD%^%^MAGENTA%^",

        "ibuild"        => "%^B_RED%^%^YELLOW%^",
        "ichat"         => "%^B_RED%^%^GREEN%^",
        "mbchat"        => "%^B_RED%^%^GREEN%^",
        "pchat"         => "%^B_RED%^%^BOLD%^%^GREEN%^",
        "i2game"        => "%^B_BLUE%^",
        "i2chat"        => "%^B_GREEN%^",
        "i3chat"        => "%^B_RED%^",
        "i2code"        => "%^B_YELLOW%^%^RED%^",
        "i2news"        => "%^B_YELLOW%^%^BLUE%^",
        "imudnews"      => "%^B_YELLOW%^%^CYAN%^",
        "irc"           => "%^B_BLUE%^%^GREEN%^",
        "ifree"         => "%^B_BLUE%^%^GREEN%^",

        "default"       => "%^BOLD%^%^BLUE%^",
        "default-IMC2"  => "%^B_BLUE%^%^BOLD%^%^WHITE%^"
    };

    return $colors->{default} if !defined $channel;
    return $colors->{$channel} if exists $colors->{$channel};
    return $colors->{default};
}

sub pinkfish_to {
    my $string = shift;
    my $style = shift;
    $style = "ansi" if !defined $style;

    return $string if $style eq "debug";
    return $string if $style eq "wiley";

    my $conversion = {
        "ansi"  => {
            '%^RESET%^'                 => "\033[0;0m",

            '%^BOLD%^'                  => "\033[1m",
            '%^FLASH%^'                 => "\033[5m",

            '%^BLACK%^'                 => "\033[30m",
            '%^RED%^'                   => "\033[31m",
            '%^GREEN%^'                 => "\033[32m",
            '%^ORANGE%^'                => "\033[33m",
            '%^BLUE%^'                  => "\033[34m",
            '%^MAGENTA%^'               => "\033[35m",
            '%^CYAN%^'                  => "\033[36m",
            '%^DARKGREY%^'              => "\033[37m",

            '%^GREY%^'                  => "\033[1;30m",
            '%^PINK%^'                  => "\033[1;31m",
            '%^LIGHTRED%^'              => "\033[1;31m",
            '%^LIGHTGREEN%^'            => "\033[1;32m",
            '%^YELLOW%^'                => "\033[1;33m",
            '%^LIGHTBLUE%^'             => "\033[1;34m",
            '%^LIGHTMAGENTA%^'          => "\033[1;35m",
            '%^LIGHTCYAN%^'             => "\033[1;36m",
            '%^WHITE%^'                 => "\033[1;37m",

            '%^B_BLACK%^'               => "\033[40m",
            '%^B_RED%^'                 => "\033[41m",
            '%^B_GREEN%^'               => "\033[42m",
            '%^B_ORANGE%^'              => "\033[43m",
            '%^B_BLUE%^'                => "\033[44m",
            '%^B_MAGENTA%^'             => "\033[45m",
            '%^B_CYAN%^'                => "\033[46m",
            '%^B_DARKGREY%^'            => "\033[47m",

            # Bold backgrounds are not supported by normal ANSI
            '%^B_GREY%^'                => "\033[40m",
            '%^B_PINK%^'                => "\033[41m",
            '%^B_LIGHTRED%^'            => "\033[41m",
            '%^B_LIGHTGREEN%^'          => "\033[42m",
            '%^B_YELLOW%^'              => "\033[43m",
            '%^B_LIGHTBLUE%^'           => "\033[44m",
            '%^B_LIGHTMAGENTA%^'        => "\033[45m",
            '%^B_LIGHTCYAN%^'           => "\033[46m",
            '%^B_WHITE%^'               => "\033[47m",
        },
        "html" => {
            '%^RESET%^'                 => '</SPAN>',

            '%^BOLD%^'                  => '<SPAN style="bold;">',
            '%^FLASH%^'                 => '<SPAN class="blink;">',

            '%^BLACK%^'                 => '<SPAN style="color: #555555">',
            '%^RED%^'                   => '<SPAN style="color: #ff5555">',
            '%^GREEN%^'                 => '<SPAN style="color: #55ff55">',
            '%^ORANGE%^'                => '<SPAN style="color: #ffaa55">',
            '%^BLUE%^'                  => '<SPAN style="color: #5555ff">',
            '%^MAGENTA%^'               => '<SPAN style="color: #ff55ff">',
            '%^CYAN%^'                  => '<SPAN style="color: #55ffff">',
            '%^DARKGREY%^'              => '<SPAN style="color: #aaaaaa">',

            '%^GREY%^'                  => '<SPAN style="color: #aaaaaa">',
            '%^PINK%^'                  => '<SPAN style="color: #ffaaaa">',
            '%^LIGHTRED%^'              => '<SPAN style="color: #ffaaaa">',
            '%^LIGHTGREEN%^'            => '<SPAN style="color: #aaffaa">',
            '%^YELLOW%^'                => '<SPAN style="color: #ffff55">',
            '%^LIGHTBLUE%^'             => '<SPAN style="color: #aaaaff">',
            '%^LIGHTMAGENTA%^'          => '<SPAN style="color: #ffaaff">',
            '%^LIGHTCYAN%^'             => '<SPAN style="color: #aaffff">',
            '%^WHITE%^'                 => '<SPAN style="color: #ffffff">',

            '%^B_BLACK%^'               => '<SPAN style="background-color: #000000">',
            '%^B_RED%^'                 => '<SPAN style="background-color: #ff0000">',
            '%^B_GREEN%^'               => '<SPAN style="background-color: #00ff00">',
            '%^B_ORANGE%^'              => '<SPAN style="background-color: #ffaa00">',
            '%^B_BLUE%^'                => '<SPAN style="background-color: #0000ff">',
            '%^B_MAGENTA%^'             => '<SPAN style="background-color: #ff00ff">',
            '%^B_CYAN%^'                => '<SPAN style="background-color: #00ffff">',
            '%^B_DARKGREY%^'            => '<SPAN style="background-color: #555555">',

            '%^B_GREY%^'                => '<SPAN style="background-color: #aaaaaa">',
            '%^B_PINK%^'                => '<SPAN style="background-color: #ffaaaa">',
            '%^B_LIGHTRED%^'            => '<SPAN style="background-color: #ffaaaa">',
            '%^B_LIGHTGREEN%^'          => '<SPAN style="background-color: #aaffaa">',
            '%^B_YELLOW%^'              => '<SPAN style="background-color: #ffff55">',
            '%^B_LIGHTBLUE%^'           => '<SPAN style="background-color: #aaaaff">',
            '%^B_LIGHTMAGENTA%^'        => '<SPAN style="background-color: #ffaaff">',
            '%^B_LIGHTCYAN%^'           => '<SPAN style="background-color: #aaffff">',
            '%^B_WHITE%^'               => '<SPAN style="background-color: #ffffff">',
        },
    };
    foreach my $k ( keys( %{ $conversion->{$style} } ) ) {
        my $v = $conversion->{$style}{$k};
        $string =~ s/\Q$k\E/$v/gsmx;
    }
    return $string;
}

sub get_final_url {
    my $url = shift;

    return undef if !defined $url;
    return undef if !defined $lwp;

    my $request = HTTP::Request->new(HEAD => $url);
    $request->header('Accept' => 'text/html');
    my $response = undef;

    if($request) {
        print timestamp() . " Got request\n" if $do_debug;
        eval {
            local $SIG{ALRM} = sub { die "Exceeded Timeout of $timeout for $url\n" };
            alarm $timeout;
            $response = $lwp->request($request);
            alarm 0;
        };
        warn timestamp() . " Timeout" if($EVAL_ERROR and ($EVAL_ERROR =~ /^Exceeded Timeout/));

        if( (defined $response) and $response->is_success ) {
            print timestamp() . " Got response\n" if $do_debug;
            my $given_uri = URI->new($url);
            my $origin_uri = $response->request->uri;
            return $origin_uri if defined $origin_uri;
            return $given_uri;
        } elsif( defined $response ) {
            print timestamp() . " Response:".Dumper($response)."\n" if $do_debug;
        }
    }
    print timestamp() . " Failed request or response\n" if $do_debug;
    return undef;
}

sub get_page {
    my $url = shift;

    return undef if !defined $url;
    return undef if !defined $lwp;

    my $request = HTTP::Request->new(GET => $url);
    my $response = undef;

    if($request) {
        eval {
            local $SIG{ALRM} = sub { die "Exceeded Timeout of $timeout for $url\n" };
            alarm $timeout;
            $response = $lwp->request($request);
            alarm 0;
        };
        warn timestamp() . " Timeout" if($EVAL_ERROR and ($EVAL_ERROR =~ /^Exceeded Timeout/));

        if( (defined $response) and $response->is_success ) {
            return $response->content;
        }
    }
    return undef;
}

sub time_parts {
    my $seconds = shift;

    return "0:00" if !defined $seconds;

    my $days    = int( $seconds / (60 * 60 * 24) );
    my $hours   = int( $seconds / (60 * 60) );
    my $minutes = int( $seconds / 60 );
    $hours      = $hours % 24;
    $minutes    = $minutes % 60;
    $seconds    = $seconds % 60;

    if( defined $days and $days > 0 ) {
        return sprintf "%d days, %d:%02d:%02d", $days, $hours, $minutes, $seconds;
    } elsif( defined $hours and $hours > 0 ) {
        return sprintf "%d:%02d:%02d", $hours, $minutes, $seconds;
    } else {
        return sprintf "%d:%02d", $minutes, $seconds;
    }
}

sub get_source {
    my $xurl = shift;

    if (defined $xurl) {
        return "YouTube"        if $xurl =~ /^https?:\/\/.*?youtube\.com/i;
        return "IMDB"           if $xurl =~ /^https?:\/\/.*?imdb\.com/i;
        return "Dailymotion"    if $xurl =~ /^https?:\/\/.*?dailymotion\.com/i;
        return "Steam"          if $xurl =~ /^https?:\/\/.*?steampowered.com/i;
    }
    return undef;
}

sub get_id {
    my $source = shift;
    my $xurl = shift;
    my $page = shift;

    return undef if !defined $source;

    if ($source eq "YouTube") {
        if( defined $xurl ) {
            #https://www.youtube.com/watch?v=PJjTHgJ6rQo
            $xurl =~ /watch\?v=([A-Za-z0-9_-]{11})/i;
            my ($id) =  ($1);
            return $id if defined $id;

            #https://www.youtube.com/playlist?list=PLGB6RkFB7ZmM3KmoGYdYD3KfSF24MTHZV
            $xurl =~ /playlist\?list=([A-Za-z0-9_-]{34})/i;
            ($id) =  ($1);
            return $id if defined $id;
        }
        if( defined $page ) {
            $page =~ /<link\s+rel=\"canonical\"\s+href=\".*?\/watch\?v=([^\"\&]*)\">/i;
            my ($id) =  ($1);
            return $id if defined $id;
        }
    } elsif ($source eq "IMDB") {
        if( defined $xurl ) {
            # http://www.imdb.com/title/tt5171438/?ref_=nv_sr_1
            $xurl =~ /\/title\/(tt\d\d\d\d\d\d\d)\//i;
            my ($id) =  ($1);
            return $id if defined $id;
        }
        if( defined $page ) {
            $page =~ /<meta\s+property=\"pageId\"\s+content=\"(tt\d\d\d\d\d\d\d)\"\s+\/>/i;
            my ($id) =  ($1);
            return $id if defined $id;
        }
    } elsif ($source eq "Dailymotion") {
        if( defined $xurl ) {
            # https://www.dailymotion.com/video/x59wnvy
            $xurl =~ /\/video\/(\w\w\w\w\w\w\w)$/i;
            my ($id) =  ($1);
            return $id if defined $id;
        }
        if( defined $page ) {
            $page =~ /<meta\s+property=\"og:url\"\s+content=\"([^\"]*)\"\/>/i;
            my ($url) =  ($1);
            return undef if !defined $url;
            $url =~ /\/(\w\w\w\w\w\w\w)$/i;
            my ($id) =  ($1);
            return $id if defined $id;
        }
    } elsif ($source eq "Steam") {
        if( defined $xurl ) {
            # http://store.steampowered.com/app/306660/Ultimate_General_Gettysburg/
            $xurl =~ /\/app\/(\d+)\//i;
            my ($id) =  ($1);
            return $id if defined $id;
        }
        if( defined $page ) {
            $page =~ /<link\s+rel=\"canonical\"\s+href=\".*?\/app\/(\d+)\/[^\"]*\">/i;
            my ($id) =  ($1);
            return $id if defined $id;
        }
    }
    return undef;
}

sub get_title {
    my $source = shift;
    my $xurl = shift;
    my $page = shift;

    return undef if !defined $page;

    if (!defined $source) {
        $page =~ /<title>\s*(.*?)\s*<\\?\/title>/i;
        my ($title) = ($1);
        $title = decode_entities($title) if defined $title;
        return $title if defined $title;
    } elsif ($source eq "YouTube" or $source eq "IMDB") {
        $page =~ /<meta\s+name=\"title\"\s+content=\"([^\"]*)\"\s*\/?>/i;
        my ($title) =  ($1);
        $title = decode_entities($title) if defined $title;
        return $title if defined $title;
    } elsif ($source eq "Dailymotion") {
        $page =~ /<meta\s+property=\"og:title\"\s+content=\"([^\"]*)\"\s*\/?>/i;
        my ($title) =  ($1);
        $title = decode_entities($title) if defined $title;
        return $title if defined $title;
    }

    return undef;
}

sub get_duration {
    my $source = shift;
    my $xurl = shift;
    my $page = shift;

    return undef if !defined $source;
    return undef if !defined $page;

    if ($source eq "YouTube") {
        $page =~ /<meta\s+itemprop=\"duration\"\s+content=\"([^\"]*)\">/i;
        my ($funky) = ($1);
        return undef if !defined $funky;

        $funky =~ /.*?(\d+)M(\d+)S/;
        my ($minutes, $seconds) = ($1, $2);

        $minutes = 0 if !defined $minutes or $minutes =~ /[^\d]/;
        $seconds = 0 if !defined $seconds or $seconds =~ /[^\d]/;
        return time_parts($minutes * 60 + $seconds);
    } elsif ($source eq "IMDB") {
        $page =~ /<time\s+itemprop=\"duration\"\s+datetime=\"PT(\d+)M\">/i;
        my ($minutes) = ($1);
        return undef if !defined $minutes;

        $minutes = 0 if !defined $minutes or $minutes =~ /[^\d]/;
        return time_parts($minutes * 60);
    } elsif ($source eq "Dailymotion") {
        $page =~ /<meta\s+property=\"video:duration\"\s+content=\"([^\"]*)\"\/>/i;
        my ($seconds) = ($1);
        return undef if !defined $seconds;

        $seconds = 0 if !defined $seconds or $seconds =~ /[^\d]/;
        return time_parts($seconds);
    }

    return undef;
}

sub read_google_api {
    my $key = undef;
    my $found = undef;
    open FP, "$GOOGLE_API_KEY_FILE" or die "Cannot find API key file $GOOGLE_API_KEY_FILE: $!";
    while($key = <FP>) {
        chomp $key;
        $key =~ s/^\s+|\s+$//g;
        if (length $key == 39) {
            $found = 1;
            last;
        }
    }
    close FP;
    die "No valid key found in $GOOGLE_API_KEY_FILE!" if !defined $found;
    return $key;
}

sub read_bitly_api {
    my $key = undef;
    my $found = undef;
    open FP, "$BITLY_API_KEY_FILE" or die "Cannot find API key file $BITLY_API_KEY_FILE: $!";
    while($key = <FP>) {
        chomp $key;
        $key =~ s/^\s+|\s+$//g;
        if (length $key == 40) {
            $found = 1;
            last;
        }
    }
    close FP;
    die "No valid key found in $BITLY_API_KEY_FILE!" if !defined $found;
    return $key;
}

sub get_youtube_api {
    my $id = shift;
    return (undef, undef) if !defined $id;

    my $page = undef;
    my $title = undef;
    my $duration = undef;

    $api_key = read_google_api() if !defined $api_key;
    print timestamp() . " Got API key\n" if defined $do_debug and defined $api_key;

    my $data_url = "https://www.googleapis.com/youtube/v3/videos?part=contentDetails%2Csnippet&id=$id&key=$api_key";
    my $request = HTTP::Request->new(GET => $data_url);
    my $response = undef;
    my $data = undef;
    print timestamp() . " Got request\n" if $do_debug;
    if($request) {
        eval {
            local $SIG{ALRM} = sub { die "Exceeded Timeout of $timeout seconds for URL\n" };
            alarm $timeout;
            $response = $lwp->request($request);
            alarm 0;
        };
        warn timestamp() . " Timeout" if($EVAL_ERROR and ($EVAL_ERROR =~ /^Exceeded Timeout/));
        if( (defined $response) and $response->is_success ) {
            #$data = decode_json encode_utf8($response->content);
            print timestamp() . " Got response\n" if $do_debug;
            $data = decode_json $response->content;
        } elsif( defined $response ) {
            print timestamp() . " Response:".Dumper($response)."\n" if $do_debug;
        }
    }
    #    "duration": "PT1H52M28S",
    if( defined $data ) {
        print timestamp() . " Got JSON data:".Dumper($data)."\n" if $do_debug;
        if( defined $data->{'items'} ) {
            if( defined $data->{'items'}[0] ) {
                if( defined $data->{'items'}[0]->{'snippet'} ) {
                    if( exists $data->{'items'}[0]->{'snippet'}->{'title'} ) {
                        $title = $data->{'items'}[0]->{'snippet'}->{'title'};
                        $title = decode_entities($title) if defined $title;
                    }
                }
                if( defined $data->{'items'}[0]->{'contentDetails'} ) {
                    if( exists $data->{'items'}[0]->{'contentDetails'}->{'duration'} ) {
                        my $funky = $data->{'items'}[0]->{'contentDetails'}->{'duration'};
                        $funky =~ /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
                        my ($hours, $minutes, $seconds) = ($1, $2, $3);
                        $hours = 0 if !defined $hours or $hours =~ /[^\d]/;
                        $minutes = 0 if !defined $minutes or $minutes =~ /[^\d]/;
                        $seconds = 0 if !defined $seconds or $seconds =~ /[^\d]/;
                        $duration = time_parts(($hours * 60 * 60) + ($minutes * 60) + $seconds);
                    }
                }
            }
        }
    }
    return ($title, $duration);
}

sub get_metadata {
    my $source = shift;
    my $the_url = shift;

    my $page = undef;
    my $id = undef;
    my $title = undef;
    my $duration = undef;

    if( defined $source and $source eq "YouTube" ) {
        $id = get_id($source, $the_url, $page);
        ($title, $duration) = get_youtube_api($id);
    } else {
        $page = get_page($the_url);
        $id = get_id($source, $the_url, $page);
        $title = get_title($source, $the_url, $page);
        $duration = get_duration($source, $the_url, $page);
    }

    $id         = "${YELLOW}[${id}]${RESET}"                        if defined $id;
    $duration   = "${RED}(${duration})${RESET}"                     if defined $duration;
    $title      = "${CYAN}${title}${RESET}"                         if defined $title;
    #$title = "${RESET}${WHITE}\xe3\x80\x8c${title}\xe3\x80\x8d${RESET}" if defined $title;

    return ($id, $title, $duration);
}

sub parse_style {
    my $arg = shift;

    return undef if !defined $arg;
    return undef if $arg =~ /^http/i;

    return "wiley"      if $arg =~ /^(--)?wiley$/;
    return "wiley"      if $arg eq '-w';
    return "ansi"       if $arg =~ /^(--)?ansi$/;
    return "ansi"       if $arg eq '-a';
    return "html"       if $arg =~ /^(--)?html$/;
    return "html"       if $arg eq '-h';
    return "debug"      if $arg =~ /^(--)?debug$/;
    return "debug"      if $arg eq '-d';
    return "sql"        if $arg =~ /^(--)?sql$/;
    return "sql"        if $arg eq '-s';
    return "checksum"   if $arg =~ /^(--)?checksum$/;
    return "checksum"   if $arg =~ /^(--)?crc32$/;
    return "checksum"   if $arg eq '-c';
    return "lpc"        if $arg =~ /^(--)?lpc$/;
    return "lpc"        if $arg eq '-l';
    return "transfer"   if $arg =~ /^(--)?transfer$/;
    return "transfer"   if $arg eq '-t';
    return "cache"      if $arg =~ /^(--)?cache$/;
    return "cache"      if $arg eq '-C';
    return "add"        if $arg =~ /^(--)?add$/;
    return "add"        if $arg eq '-A';

    return undef;
}

sub get_tinyurl {
    my $given = shift;
    my $origin = shift;
    my $result = undef;

    # http://tinyurl.com/y9jzgz7o
    
    if( defined $given ) {
        return $given if length $given <= 27;
        return $given if $given =~ /tinyurl\.com\/\w\w\w\w\w\w\w$/i;
        return $given if $given =~ /bit\.ly\/\w\w\w\w\w\w\w$/i;
        return $given if $given =~ /t\.co\/\w\w\w\w\w\w\w\w\w\w$/i;
    }

    if( defined $origin ) {
        return $origin if length $origin <= 27;
        return $origin if $origin =~ /tinyurl\.com\/\w\w\w\w\w\w\w$/i;
        return $origin if $origin =~ /bit\.ly\/\w\w\w\w\w\w\w$/i;
        return $origin if $origin =~ /t\.co\/\w\w\w\w\w\w\w\w\w\w$/i;
    }

    my $check = (defined $origin) ? $origin : $given;
    eval {
        local $SIG{ALRM} = sub { die "Exceeded Timeout of $timeout for $url\n" };
        alarm $timeout;
        $result = makeashorterlink($check);
        #my $token = read_bitly_api();
        #my $bitly = WWW::Shorten::Bitly->new(
        #    access_token => $token,
        #);
        #$result = $bitly->shorten(longUrl => $check);
        print STDERR timestamp() . " ShortURL = " . Dumper($result) . "\n" if defined $do_debug;
        $result = $result->{url} if defined $result;
        alarm 0;
    };
    warn timestamp() . " Timeout" if($EVAL_ERROR and ($EVAL_ERROR =~ /^Exceeded Timeout/));
    $result = $result->[0] if ref $result eq 'ARRAY';
    return $result;
}

sub get_channel {
    my $channel = shift;
    my $speaker = shift;

    if( defined $channel ) {
        my $chan_color = channel_color($channel);
        #$channel = "$speaker\@$channel" if defined $speaker;
        $channel = "$speaker on $channel" if defined $speaker;
        if( defined $chan_color ) {
            $channel = "${chan_color}<${channel}>${RESET}";
        } else {
            $channel = "<${channel}>";
        }
    }

    return $channel;
}

sub format_output {
    my $style = shift;
    my $source = shift;
    my $given_host = shift;
    my $origin_host = shift;
    my $tinyurl = shift;
    my $id = shift;
    my $channel = shift;
    my $title = shift;
    my $duration = shift;

    # tiny :: Youtube [foo] on <blah> is Title (1:00)
    # tiny :: Youtube URL on <blah> is Title (1:00)
    # tiny :: foo.com URL on <blah> is Title from arg.com
    # tiny :: foo.com URL on <blah> goes to arg.com
    # tiny :: foo.com URL on <blah> is Title
    # tiny :: foo.com URL on <blah>

    my $two_hosts = 0;
    $two_hosts = 1 if defined $origin_host and $given_host ne $origin_host;

    my $output  = "${RESET}";
       $output .= "${GREEN}$tinyurl :: ${RESET}"        if defined $tinyurl;
       $output .= "${source}"                           if defined $source;
       $output .= "${given_host}"                       if !defined $source;
       $output .= " ${id}"                              if defined $id;
       $output .= " URL"                                if !defined $id;
       $output .= " from ${channel}"                    if defined $channel and "$channel" ne "";
       $output .= " is ${title}"                        if defined $title and "$title" ne "";
       $output .= " ${duration}"                        if defined $duration;
       $output .= " at ${origin_host}"                  if !defined $source and defined $title and $two_hosts;
       $output .= " goes to ${origin_host}"             if !defined $source and !defined $title and $two_hosts;
       chomp $output;
       #$output .= "\n";

    return $output;
}

sub handle_url {
    # This function can be called in two ways.
    #
    # handle_url($row)
    #     In this case, $row is a reference to a database row retrieved
    #     via DBI as a hashref, and explicitly blessed as 'DBI' by the
    #     caller to avoid mishaps.
    # handle_url($url, $channel)
    #     In this case, both arguments are simple strings, and the channel
    #     may be undef if not applicable (command line use).
    #
    my $sql_row = shift;
    my $url = undef;
    my $channel = undef;
    my $speaker = undef;
    my $result = {};

    # This check works because isa() can always be called on a non-reference
    # or on a blessed reference.  For a non-reference, it always returns undef.
    # If you pass in an unblessed reference, this will crash.
    if( defined $sql_row and $sql_row->isa('DBI')) {
        $url = $sql_row->{'url'};
        $channel = $sql_row->{'channel'};
        $speaker = $sql_row->{'speaker'};
    } else {
        $url = $sql_row;
        $channel = shift;
        $speaker = shift;
        $sql_row = undef;
    }
    #print Dumper( [ $sql_row, $url, $channel ] );

    $RESET   = pinkfish_to( "%^RESET%^", $style );
    $YELLOW  = pinkfish_to( "%^YELLOW%^", $style );
    $RED     = pinkfish_to( "%^RED%^", $style );
    $GREEN   = pinkfish_to( "%^GREEN%^", $style );
    $CYAN    = pinkfish_to( "%^CYAN%^", $style );
    $WHITE   = pinkfish_to( "%^WHITE%^", $style );
    $FLASH   = pinkfish_to( "%^FLASH%^", $style );

    my $given_uri = URI->new($url);
    my $given_host = $given_uri->host;
    my $origin = get_final_url($url);
    my $origin_host = $origin->host if defined $origin;

    my $tinyurl = get_tinyurl($url, $origin);
    my $the_url = (defined $origin_host) ? $origin : $url;
    my $source = get_source($the_url);

    my $mud_speaker = undef;
    my $mud_mud = undef;

    $result->{channel} = $channel;
    ($mud_speaker, $mud_mud) = (split /\@/, $speaker) if defined $speaker;
    $mud_mud = 'WileyMUD' if defined $speaker and !defined $mud_mud;
    $result->{speaker} = $mud_speaker;
    $result->{mud} = $mud_mud;
    $result->{url} = $url;

    $channel = get_channel($channel, $speaker);
    my ($id, $title, $duration) = get_metadata($source, $the_url);
    my $output = format_output($style, $source, $given_host, $origin_host,
                               $tinyurl, $id, $channel, $title, $duration);
    my $message = pinkfish_to( $output, $style );
    my $utf8 = encode("UTF-8", $message);
    #my $entities = encode_entities($utf8);
    $message = $utf8;

    $result->{tiny} = $tinyurl;
    $result->{message} = $message;

    if(defined $sql_row) {
        $db->begin_work();
        my $rv = $update_sql->execute($message, $tinyurl, $sql_row->{'created'}, $sql_row->{'url'});
        if($rv) {
            $db->commit;
        } else {
            print STDERR $DBI::errstr."\n";
            $db->rollback;
        }
    } else {
        if( $do_debug ) {
            $message .= "\n";
            $message .= Dumper({
                   'source' => $source,
                   'id' => $id,
                   'title' => $title,
                   'duration' => $duration,
                   'channel' => $channel,
                   'given_host' => $given_host,
                   'origin_host' => $origin_host,
                   'the_url' => $the_url,
                   'given_uri' => $url,
                   'tinyurl' => $tinyurl,
                   'output' => $output,
                });
            $message .= "\n";
        }
        print "$message\n";
    }
    return $result;
}

$url = shift;
$style = parse_style($url);

if( !defined $style ) {
    $style = 'ansi';
} else {
    $url = shift;
}

if( !defined $url and $style ne 'sql' and $style ne 'checksum' and $style ne 'lpc' and $style ne 'transfer' and $style ne 'cache') {
    print "Usage: $prog [wiley|ansi|html|debug] URL [channel] [speaker]\n";
    print "       $prog sql [limit] [--mark]\n";
    print "       $prog checksum [limit]\n";
    print "       $prog lpc [limit]\n";
    print "       $prog transfer [limit]\n";
    print "       $prog cache URL [channel] [speaker]\n";
    print "       $prog add URL [channel] [speaker]\n";
    exit 1;
}

if( $style eq 'sql' ) {
    $do_sql = 1;
    $style = 'wiley';
} elsif( $style eq 'checksum' ) {
    $do_checksum = 1;
    $style = 'wiley';
} elsif( $style eq 'debug' ) {
    $do_debug = 1;
    $style = 'wiley';
} elsif( $style eq 'lpc' ) {
    $do_lpc = 1;
    $style = 'wiley';
} elsif( $style eq 'transfer' ) {
    $do_transfer = 1;
    $style = 'wiley';
} elsif( $style eq 'cache' ) {
    $do_cache = 1;
    $style = 'wiley';
} elsif( $style eq 'add' ) {
    $do_add = 1;
    $style = 'wiley';
}

$channel = shift;
$speaker = shift;

$url =~ s/\&ab_channel\=(?:.*?)$//; # Remove youtube's latest stupidity...

#print STDERR Dumper( [ $do_sql, $url, $style, $channel ] );
if( $do_sql ) {
    #$sqlite_db = DBI->connect("DBI:SQLite:dbname=$DB_FILE", '', '', { AutoCommit => 1, PrintError => 0, });
    $db = DBI->connect("dbi:Pg:dbname=$DB_NAME", 'wiley', 'tardis69', { AutoCommit => 1, RaiseError => 1, PrintError => 0, });
    # Fetch all the matches and stuff them into an array of hashes
    $result = $db->selectall_arrayref(qq!
        SELECT created, url, channel, speaker
          FROM urls
         WHERE processed IS NOT TRUE AND message IS NULL
      ORDER BY created ASC
      !, { Slice => {} });

    my $left = scalar @$result;
    my $limit;
    $limit = $url if defined $url and $url =~ /^\d+$/;
    $limit = $left if !defined $limit;
    my $mark_processed;
    $mark_processed = 1 if defined $channel and $channel =~ /^(\-\-)?mark/i;

    if( $mark_processed ) {
        $update_sql = $db->prepare( qq!
            UPDATE urls
               SET message = ?, tiny = ?, processed = TRUE
             WHERE created = ? AND url = ? AND processed IS NOT TRUE AND message IS NULL
            !);
    } else {
        $update_sql = $db->prepare( qq!
            UPDATE urls
               SET message = ?, tiny = ?
             WHERE created = ? AND url = ? AND processed IS NOT TRUE AND message IS NULL
            !);
    }

    printf("%d URLs to process, only doing %d.\n", $left, $limit) if $left > $limit;
    $left = $limit if $left > $limit;

    foreach my $r (@$result) {
        my $url = $r->{'url'};
        bless $r, 'DBI';
        printf "% 5d : %s...\n", $left--, substr($url, 0, 50);
        handle_url( $r );
        last if $left <= 0;
    }
    $db->disconnect();
} elsif( $do_checksum ) {
    #$sqlite_db = DBI->connect("DBI:SQLite:dbname=$DB_FILE", '', '', { AutoCommit => 1, PrintError => 0, });
    $db = DBI->connect("dbi:Pg:dbname=$DB_NAME", 'wiley', 'tardis69', { AutoCommit => 1, RaiseError => 1, PrintError => 0, });
    $result = $db->selectall_arrayref(qq!
        SELECT created, url
          FROM urls
         WHERE checksum IS NULL
      ORDER BY created ASC
      !, { Slice => {} });
    $update_sql = $db->prepare( qq!
        UPDATE urls
           SET checksum = ?
         WHERE created = ? AND url = ? AND checksum IS NULL
        !);
    my $left = scalar @$result;
    my $limit;
    $limit = $url if defined $url and $url =~ /^\d+$/;
    $limit = $left if !defined $limit;

    printf("%d URLs to process, only doing %d.\n", $left, $limit) if $left > $limit;
    $left = $limit if $left > $limit;

    foreach my $sql_row (@$result) {
        my $url = $sql_row->{'url'};
        my $checksum = sprintf("%08x", crc32($url, length $url));
        $url .= "\0" x 50;

        $db->begin_work();
        my $rv = $update_sql->execute($checksum, $sql_row->{'created'}, $sql_row->{'url'});
        if($rv) {
            $db->commit;
            printf "% 5d - %s : %s...\n", $left--, $checksum, substr($url, 0, 50);
        } else {
            print STDERR $DBI::errstr."\n";
            $db->rollback;
        }
        last if $left <= 0;
    }
    $db->disconnect();
} elsif( $do_lpc ) {
    # LPC: checksum : ({ url, counter, time, channel, user, mud, result })
    # time is seconds since epoch
    # counter is number of times seen, defaults to 1
    # result is fancy output from untiny
    #
    # SQL: CREATE TABLE urls (
    #           created DATETIME DEFAULT (STRFTIME('%Y-%m-%d %H:%M:%f', 'NOW','utc')),
    #           processed INTEGER,
    #           channel TEXT,
    #           speaker TEXT,
    #           mud TEXT,
    #           url TEXT,
    #           message TEXT,
    #           checksum TEXT);

    #$sqlite_db = DBI->connect("DBI:SQLite:dbname=$DB_FILE", '', '', { AutoCommit => 1, PrintError => 0, });
    $db = DBI->connect("dbi:Pg:dbname=$DB_NAME", 'wiley', 'tardis69', { AutoCommit => 1, RaiseError => 1, PrintError => 0, });
    $result = $db->selectall_arrayref(qq!
        SELECT checksum,
               url,
               1 AS counter,
               EXTRACT(epoch FROM created) AS time,
               channel,
               speaker AS user,
               mud,
               message AS result
          FROM urls
         WHERE message IS NOT NULL
      ORDER BY time ASC
      !, { Slice => {} });

    my $left = scalar @$result;
    my $limit;
    $limit = $url if defined $url and $url =~ /^\d+$/;
    $limit = $left if !defined $limit;

    open FP, ">$LPC_DUMP_FILE" or die "Cannot open LPC dump file $LPC_DUMP_FILE $!";
    printf FP "urls ([";
    foreach my $r (@$result) {
        my $url = $r->{'url'};
        printf "% 5d : %s...\n", $left--, substr($url, 0, 50);
        printf FP "\"%s\":([\"url\":\"%s\",\"counter\":%d,\"time\":\"%d\",\"channel\":\"%s\",\"user\":\"%s\",\"mud\":\"%s\",\"result\":\"%s\",]),",
            $r->{'checksum'},
            $r->{'url'},
            $r->{'counter'},
            $r->{'time'},
            $r->{'channel'},
            $r->{'user'},
            $r->{'mud'},
            $r->{'result'};
        last if $left <= 0;
    }
    printf FP "])\n";
    close FP;
    $db->disconnect();
} elsif( $do_transfer ) {
    $sqlite_db = DBI->connect("DBI:SQLite:dbname=$DB_FILE", '', '', { AutoCommit => 1, PrintError => 0, });
    $db = DBI->connect("dbi:Pg:dbname=$DB_NAME", 'wiley', 'tardis69', { AutoCommit => 1, RaiseError => 1, PrintError => 0, });

    # created DATETIME DEFAULT (STRFTIME('%Y-%m-%d %H:%M:%f', 'NOW','utc')),
    # processed INTEGER,
    # channel TEXT,
    # speaker TEXT,
    # mud TEXT,
    # url TEXT,
    # message TEXT,
    # checksum TEXT
    $result = $sqlite_db->selectall_arrayref(qq!
        SELECT created,
               processed,
               channel,
               speaker,
               mud,
               url,
               message,
               checksum
          FROM urls
      ORDER BY created ASC
      !, { Slice => {} });
    my $left = scalar @$result;
    my $limit;
    $limit = $url if defined $url and $url =~ /^\d+$/;
    $limit = $left if !defined $limit;

    printf("%d URLs to process, only doing %d.\n", $left, $limit) if $left > $limit;
    $left = $limit if $left > $limit;

    $update_sql = $db->prepare( qq!
        INSERT INTO urls (created, processed, channel, speaker, mud, url, message, checksum )
        VALUES (?,?,?,?,?,?,?,?)
        ON CONFLICT (checksum)
        DO NOTHING
        !);
    foreach my $sql_row (@$result) {
        $left--;
        if(defined $sql_row->{'message'} and length $sql_row->{'message'} > 512) {
            print "Skipping stupidly long url" . $sql_row->{created} . "\n";
            next;
        }
        $db->begin_work();
        my $rv = $update_sql->execute(
            $sql_row->{'created'}, $sql_row->{'processed'},
            $sql_row->{'channel'}, $sql_row->{'speaker'},
            $sql_row->{'mud'}, $sql_row->{'url'},
            $sql_row->{'message'}, $sql_row->{'checksum'}
        );
        if($rv) {
            $db->commit;
        } else {
            print STDERR $DBI::errstr."\n";
            $db->rollback;
        }
        last if $left <= 0;
    }
    $db->disconnect();
    $sqlite_db->disconnect();
} elsif( $do_cache ) {
    $db = DBI->connect("dbi:Pg:dbname=$DB_NAME", 'wiley', 'tardis69', { AutoCommit => 1, RaiseError => 1, PrintError => 0, });
    my $cached = $db->selectrow_hashref(qq!
        SELECT message
          FROM urls
         WHERE message IS NOT NULL AND url = ?
      ORDER BY created ASC
         LIMIT 1
      !, undef, ($url));
    if(defined $cached and defined $cached->{message}) {
        print $cached->{message};
    } else {
        print '<SPAN class="flash_tag" style="color: red;">COMING SOON!</SPAN>' . "\n";
    }
    $db->disconnect();
} elsif( $do_add ) {
    my $result = handle_url( $url, $channel, $speaker );
    print Dumper($result);
    exit 1;
    # Eventually, add this to the database and then do what do_sql does for it.
    $db = DBI->connect("dbi:Pg:dbname=$DB_NAME", 'wiley', 'tardis69', { AutoCommit => 1, RaiseError => 1, PrintError => 0, });
    $db->disconnect();
} else {
    handle_url( $url, $channel, $speaker );
}

exit 1;

