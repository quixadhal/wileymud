#!/usr/bin/env python3

"""
LiFX packet generator

Simple implementation of colour-sending functionality,
without the ACK/retry functionality. Send only, no listen.

Author: Petr Klus
"""

import socket
import time
import sys
import random
from struct import pack, unpack
import logging
from textwrap import wrap

logger = logging.getLogger("lifx_packet_tools")

MY_BULBS = (80, 81, 82, 83, 84, 85)
BULB_NAMES = {
        "all"           : [80, 81, 82, 83, 84, 85],
        "front"         : [81, 82],
        "back"          : [83, 84],
        "others"        : [80, 85],
        "frontleft"     : [81],
        "frontright"    : [82],
        "backright"     : [83],
        "backleft"      : [84],
        "kitchen"       : [80],
        "bathroom"      : [85],
        }

RETRIES = 5
DELAY = 0.05
UDP_PORT = 56700
SEQ_NUM = random.randint(0, 255)

DURATION = 0        # In theory a transition time, but seems to do nothing?
KELVIN = 9000
HUE = 0
SATURATION = 100
VALUE = 50

MESSAGE_SET_COLOR = 102
MESSAGE_SET_POWER = 117

MESSAGE_SET_COLOR_ZONES = 501

NO_APPLY = 0
APPLY = 1
APPLY_ONLY = 2

def gen_packet_universal(seq_num, message_type, payload):
    # size
    #packet = b"\x31\x00"

    # binary field
    packet = b"\x00\x34"

    # source
    packet += b"\x00\x00\x00\x00"

    # frame address
    packet += b"\x00\x00\x00\x00\x00\x00\x00\x00"

    # reserved section
    packet += b"\x00\x00\x00\x00\x00\x00"  # NOQA

    # we actually want 6 bits of padding and 2 bits of 1s,
    # res_required and ack_required
    packet += pack(">B", 3)

    packet += pack("<B", seq_num)  # sequence number

    # protocol header
    packet += b"\x00\x00\x00\x00\x00\x00\x00\x00" # padding
    packet += pack("<H", message_type)   # type
    packet += b"\x00\x00"   # padding

    # payload
    packet += payload

    # finally, calculate size adjusting for the size information itself
    packet = pack("<H", len(packet)+2) + packet + b"\x00"

    return packet


def gen_packet(hue=HUE, sat=SATURATION, bri=VALUE, kel=KELVIN, duration=DURATION, seq_num=1):
    if hue < 0 or hue > 360:
        raise Exception("Invalid hue: 0-360")
    if sat < 0 or sat > 100:
        raise Exception("Invalid sat: 0-100")
    if bri < 0 or bri > 100:
        raise Exception("Invalid bri: 0-100")
    if kel < 2500 or kel > 9000:
        raise Exception("Invalid kel: 2500-9000")

    def calc_hue(hue):
        return int(hue / 360.0 * 65535)  # degrees

    def calc_sat(sat):
        return int(sat / 100.0 * 65535)  # percentage

    def calc_bri(bri):
        return int(bri / 100.0 * 65535)  # percentage

    payload = b"\x00"
    payload += pack("<H", calc_hue(hue))
    payload += pack("<H", calc_sat(sat))
    payload += pack("<H", calc_bri(bri))
    payload += pack("<H", int(kel))

    transition_time = pack("<L", DURATION)
    payload += transition_time

    return gen_packet_universal(seq_num, MESSAGE_SET_COLOR, payload)


def get_power_packet(seq_num, power_state):
    if type(power_state) != type(True):
        raise Exception("Invalid power state")

    if power_state:
        payload = pack(">H", 65535) # 1 - switched on
    else:
        payload = pack(">H", 0)     # 0 - switched off

    payload += pack("<L", DURATION)      # duration

    return gen_packet_universal(seq_num, MESSAGE_SET_POWER, payload)



def get_colour_zones_packet(start_index, end_index,
    hue, sat, bri, kel, apply_changes, seq_num):

    if start_index < 0 or start_index > 255:
        raise Exception("Invalid start_index: 0-255")
    if end_index < 0 or end_index > 255:
        raise Exception("Invalid end_index: 0-255")
    if start_index > end_index:
        raise Exception("Invalid end_index: needs to be < start_index")
    if hue < 0 or hue > 360:
        raise Exception("Invalid hue: 0-360")
    if sat < 0 or sat > 100:
        raise Exception("Invalid sat: 0-100")
    if bri < 0 or bri > 100:
        raise Exception("Invalid bri: 0-100")
    if kel < 2500 or kel > 9000:
        raise Exception("Invalid kel: 2500-9000")
    if apply_changes not in [0, 1, 2]:
        raise Exception("Invalid apply_changes, allowed: 0, 1 or 2")

    def calc_hue(hue):
        return int(hue / 360.0 * 65535)  # degrees

    def calc_sat(sat):
        return int(sat / 100.0 * 65535)  # percentage

    def calc_bri(bri):
        return int(bri / 100.0 * 65535)  # percentage

    payload = pack("<B", start_index)
    payload += pack("<B", end_index)

    payload += pack("<H", calc_hue(hue))
    payload += pack("<H", calc_sat(sat))
    payload += pack("<H", calc_bri(bri))
    payload += pack("<H", int(kel))

    payload += pack("<L", DURATION)      # duration
    payload += pack("<B", apply_changes) # apply_changes

    logger.debug("test")
    return gen_packet_universal(seq_num, MESSAGE_SET_COLOR_ZONES, payload)



def set_HSBK(bulb_ip, hue=HUE, sat=SATURATION, bri=VALUE, kel=KELVIN, dur=DURATION):
    print(f"Sending {hue} {sat} {bri} {kel} {dur} => {bulb_ip}")
    for _ in range(RETRIES):
        sock.sendto(gen_packet(hue, sat, bri, kel, dur, SEQ_NUM),
                    (bulb_ip, UDP_PORT))
        #time.sleep(DELAY)

if __name__ == "__main__":
    print(sys.argv)

    # different for each execution

    #print("Using sequence number:", SEQ_NUM)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # UDP

    arg_len = len(sys.argv)
    if arg_len < 2:
        print("Usage: " + sys.argv[0] + " <bulb IP> <hue> <saturation> <value> <kelvin> <transition>")
        print("       <bulb IP> can be an IPv4 address or one of these names:")
        print("       " + "\n       ".join(wrap(", ".join(BULB_NAMES.keys()))))
        sys.exit()

    bulb_ip = sys.argv[1]

    if sys.argv[1] == "help":
        print("Usage: " + sys.argv[0] + " <bulb IP> <hue> <saturation> <value> <kelvin> <transition>")
        print("       <bulb IP> can be an IPv4 address or one of these names:")
        print("       " + "\n       ".join(wrap(", ".join(BULB_NAMES.keys()))))
        sys.exit()
    elif sys.argv[1] == "test":
        print("Testing H")
        for x in range(80):
            for b in MY_BULBS:
                bulb_ip = f"192.168.0.{b}"
                set_HSBK(bulb_ip, 360/80*x, 100, 100, 3500, 100)
            time.sleep(0.1)
        print("Testing S")
        for x in range(21):
            for b in MY_BULBS:
                bulb_ip = f"192.168.0.{b}"
                set_HSBK(bulb_ip, 120, x*5, 100, 3500, 100)
            time.sleep(0.1)
        print("Testing B")
        for x in range(11):
            for b in MY_BULBS:
                bulb_ip = f"192.168.0.{b}"
                set_HSBK(bulb_ip, 360, 100, x*10, 3500, 100)
            time.sleep(0.1)
        print("Testing K")
        for x in range(10):
            for b in MY_BULBS:
                bulb_ip = f"192.168.0.{b}"
                set_HSBK(bulb_ip, 360, 0, 100, 6500/10*x+2500, 100)
            time.sleep(0.3)
    else:
        hue=HUE
        sat=SATURATION
        bri=VALUE
        kel=KELVIN
        dur=DURATION

        if arg_len > 2:
            hue = int(sys.argv[2])

        if arg_len > 3:
            sat = int(sys.argv[3])

        if arg_len > 4:
            bri = int(sys.argv[4])

        if arg_len > 5:
            kel = int(sys.argv[5])

        if arg_len > 6:
            dur = int(sys.argv[6])

        #hue, sat, bri, kel, dur = map(int, sys.argv[2:])

        found = False
        for k,v in BULB_NAMES.items():
            if sys.argv[1] == k:
                found = True
                for b in v:
                    bulb_ip = f"192.168.0.{b}"
                    set_HSBK(bulb_ip, hue, sat, bri, kel, dur)

        if not found:
            set_HSBK(bulb_ip, hue, sat, bri, kel, dur)

        #if sys.argv[1] == "all":
        #    for b in MY_BULBS:
        #        bulb_ip = f"192.168.0.{b}"
        #        set_HSBK(bulb_ip, hue, sat, bri, kel, dur)
        #else:
        #    set_HSBK(bulb_ip, hue, sat, bri, kel, dur)

