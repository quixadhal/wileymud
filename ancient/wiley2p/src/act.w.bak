/* ************************************************************************
*  file: actwiz.c , Implementation of commands.           Part of DIKUMUD *
*  Usage : Wizard Commands.                                               *
*  Copyright (C) 1990, 1991 - see 'license.doc' for complete information. *
************************************************************************* */

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "limits.h"
#include "race.h"

/*   external vars  */
extern int DEBUG;
extern int DEBUG2;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern struct hash_header room_db;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct title_type titles[4][ABS_MAX_LVL];
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern int top_of_mobt;
extern int top_of_objt;
extern struct int_app_type int_app[26];
extern struct wis_app_type wis_app[26];

/* external functs */

void set_title(struct char_data *ch);
int str_cmp(char *arg1, char *arg2);
struct time_info_data age(struct char_data *ch);
void sprinttype(int type, char *names[], char *result);
void sprintbit(unsigned long, char *[], char *);
int mana_limit(struct char_data *ch);
int hit_limit(struct char_data *ch);
int move_limit(struct char_data *ch);
int mana_gain(struct char_data *ch);
int hit_gain(struct char_data *ch);
int move_gain(struct char_data *ch);
void RoomSave(struct char_data *ch, int start, int end);
void RoomLoad(struct char_data *ch, int start, int end);
void do_look(struct char_data *ch, char *argument, int cmd);

void do_polymorph(struct char_data *ch, char *argument, int cmdnum)
{


}

void do_instazone(struct char_data *ch, char *argument, int cmdnum)
{
  char cmd, c, buf[80];
  int i, start_room, end_room, j, arg1, arg2, arg3;
  struct char_data *p;
  struct obj_data *o;
  struct room_data *room;
  FILE *fp;
  
 if(DEBUG) dlog("do_instazone"); 
  if (IS_NPC(ch))
    return;
  
  /*
   *   read in parameters (room #s)
   */
  start_room = -1; end_room = -1;
  sscanf(argument, "%d%c%d", &start_room, &c, &end_room);
  
  if ((start_room == -1) || (end_room == -1)) {
    send_to_char("mkzone <start_room> <end_room>\n\r", ch);
    return;
  }
  
  fp = (FILE *)MakeZoneFile(ch);
  
  if (!fp) {
    send_to_char("Couldn't make file.. try again later\n\r", ch);
    return;
  }
  
  for (i = start_room; i<=end_room; i++) {
    room = real_roomp(i);
    if (room) {
      
      /*
       *  first write out monsters
       */
      for (p = room->people; p; p = p->next_in_room) {
  if (IS_NPC(p)) {
    cmd = 'M';
    arg1 = MobVnum(p);
    arg2 = mob_index[p->nr].number;
    arg3 = i;
    Zwrite(fp, cmd, 0, arg1, arg2, arg3, p->player.short_descr);
    for (j = 0; j<MAX_WEAR; j++) {
      if (p->equipment[j]) {
        if (p->equipment[j]->item_number >= 0) {
    cmd = 'E'; 
    arg1 = ObjVnum(p->equipment[j]);
    arg2 = obj_index[p->equipment[j]->item_number].number;
    arg3 = j;
    strcpy(buf, p->equipment[j]->short_description);
    Zwrite(fp, cmd,1,arg1, arg2, arg3, 
           buf);
    RecZwriteObj(fp, p->equipment[j]);
        }
      }
    }
    for (o = p->carrying; o; o=o->next_content) {
      if (o->item_number >= 0) {
        cmd = 'G';
        arg1 = ObjVnum(o);
        arg2 = obj_index[o->item_number].number;
        arg3 = 0;
              strcpy(buf, o->short_description);
        Zwrite(fp, cmd, 1, arg1, arg2, arg3, buf);
        RecZwriteObj(fp, o);
      }
    }
  }
      }
      /*
       *  write out objects in rooms
       */
      for (o = room->contents; o; o= o->next_content) {
  if (o->item_number >= 0) {
    cmd = 'O';
    arg1 = ObjVnum(o);
    arg2 = obj_index[o->item_number].number;
    arg3 = i;
          strcpy(buf, o->short_description);
    Zwrite(fp, cmd, 0, arg1, arg2, arg3, buf);
    RecZwriteObj(fp, o);
  }
      }
      /*
       *  lastly.. doors
       */
      
      for (j = 0; j < 6; j++) {
  /*
   *  if there is an door type exit, write it.
   */
  if (room->dir_option[j]) {  /* is a door */
    if (room->dir_option[j]->exit_info) {
      cmd = 'D';
      arg1 = i ;
      arg2 = j;
      arg3 = 0;
      if (IS_SET(room->dir_option[j]->exit_info, EX_CLOSED)) {
        arg3 = 1;
      }
      if (IS_SET(room->dir_option[j]->exit_info, EX_LOCKED)) {
        arg3 = 2;
      }
      Zwrite(fp, cmd, 0, arg1, arg2, arg3, room->name);
    }
  }
      }
    }
  }
  fclose(fp);

}


do_highfive(struct char_data *ch, char *argument, int cmd)
{
  char buf[80];
  char mess[120];
  struct char_data *tch;

if(DEBUG) dlog("do_highfive");
  if (argument) {
    only_argument(argument, buf);
    if ((tch = get_char_vis(ch,buf)) != 0) {
      if ((GetMaxLevel(tch) >= DEMIGOD) && (!IS_NPC(tch))) {
       sprintf(mess, "Time stops for a moment as %s and %s high five.\n\r",
      ch->player.name, tch->player.name);
       send_to_all(mess);
      } else {
       act("$n gives you a high five", TRUE, ch, 0, tch, TO_VICT);
       act("You give a hearty high five to $N", TRUE, ch, 0, tch, TO_CHAR);
       act("$n and $N do a high five.", TRUE, ch, 0, tch, TO_NOTVICT);
      }
    } else {
      sprintf(buf,"I don't see anyone here like that.\n\r");
      send_to_char(buf,ch);
    }
  }
}


do_wizlock(struct char_data *ch, char *argument, int cmd)
{

  extern int WizLock;
if(DEBUG) dlog("do_wizlock");
  if (IS_NPC(ch)) {
    send_to_char("You cannot WizLock.\n\r",ch);
    return(FALSE);
  }

  if (WizLock) {
    send_to_char("WizLock is now off\n\r",ch);
    log("Wizlock is now off.");
    WizLock = FALSE;
  } else {
    send_to_char("WizLock is now on\n\r",ch);
    log("WizLock is now on.");
    WizLock = TRUE;
  }

  return;

}

do_rload(struct char_data *ch, char *argument, int cmd)
{
   char i;
   int start= -1, end = -2; 
if(DEBUG) dlog("do_rload");
   if (IS_NPC(ch)) return;
   if (GetMaxLevel(ch) < IMMORTAL) return;

   for (i = 0; *(argument + i) == ' '; i++);
   if (!*(argument + i)) {
      send_to_char("lroom <start> <end>\n\r", ch);
      return;
    }
    sscanf(argument,"%d %d", &start, &end);
      
    if ((start <= end) && (start != -1) && (end != -2)) 
    {
      RoomLoad(ch,start,end);
    }
}

do_rsave(struct char_data *ch, char *argument, int cmd)
{
   char i, buf[256];
   int start= -1, end = -2; 
if(DEBUG) dlog("do_rsave");
   if (IS_NPC(ch)) return;

   if (GetMaxLevel(ch) < IMMORTAL) return;

   for (i = 0; *(argument + i) == ' '; i++);
   if (!*(argument + i)) {
      send_to_char("sroom <start> <end>\n\r", ch);
      return;
    }
    sscanf(argument,"%d %d", &start, &end);
      
    if ((start <= end) && (start != -1) && (end != -2)) {
      sprintf(buf,"mv %s %s.bak", GET_NAME(ch), GET_NAME(ch));
      system(buf);
      RoomSave(ch,start,end);
    }
}


do_emote(struct char_data *ch, char *argument, int cmd)
{
  int i;
  char buf[MAX_INPUT_LENGTH];
if(DEBUG) dlog("do_emote");
  if (IS_NPC(ch) && (cmd != 0))
    return;

  for (i = 0; *(argument + i) == ' '; i++);

  if (!*(argument + i))
    send_to_char("Yes.. But what?\n\r", ch);
  else  {
    sprintf(buf,"$n %s", argument + i);
    act(buf,FALSE,ch,0,0,TO_ROOM);
    send_to_char("Ok.\n\r", ch);
  }
}

do_set(struct char_data *ch, char *argument, int cmd)
{
  char field[20], name[20], parmstr[50];
  int index;
  struct char_data *mob;
  int parm, parm2;
  char *pset_list[] = 
  {
    "align",
    "exp",
    "sex",
    "race",
    "hit",
    "mhit",
    "tohit",
    "bank",
    "gold",
    "prac",
    "str",
    "int",
    "wis",
    "dex",
    "con",
    "stradd",
    '\0'
  };

  char tmp[80];
if(DEBUG) dlog("do_set");
  if (IS_NPC(ch))
     return;

  argument = one_argument(argument, name);
  argument = one_argument(argument, field);
  strncpy(tmp,argument,79);
  argument = one_argument(argument, parmstr);

  if ((mob = get_char_vis(ch, name)) == NULL) 
  {
    send_to_char("I don't see them here? \n\r\n\r",ch);
    send_to_char("Usage: pset <name> <att> <val>\n\r",ch);
    send_to_char("att: align, exp, sex, race, hit, mhit\n\r",ch);
    send_to_char("     tohit, bank, gold, prac\n\r",ch); 
    return;
  }

  for(index=0;pset_list[index];index++)
    if(!strcmp(field,pset_list[index]))
    {
      sscanf(parmstr,"%d",&parm);
      if(!parm)
      {
	send_to_char("You must also supply a value\n\r",ch);
	return;
      }
      break;
    }

      switch(index)
      {
        case 0:
          GET_ALIGNMENT(mob) = parm;
        break;
	case 1:
          GET_EXP(mob) = parm;
        break;
	case 2:
          GET_SEX(mob) = parm;
        break;
	case 3:
          GET_RACE(mob) = parm;
	break;
        case 4:
          GET_HIT(mob) = parm;
        break;
        case 5:
          mob->points.max_hit = parm;
        break;
	case 6:
          GET_HITROLL(mob)=parm;
	break;
	case 7:
          GET_BANK(mob) = parm;
	break;
	case 8:
          GET_GOLD(mob) = parm;
	break;
	case 9:
          mob->specials.spells_to_learn = parm;
	break;
	case 10:
	  mob->abilities.str = parm;
	  mob->tmpabilities = mob->abilities;
        break;
	case 11:
	  mob->abilities.intel = parm;
	  mob->tmpabilities = mob->abilities;
        break;
	case 12:
	  mob->abilities.wis = parm;
	  mob->tmpabilities = mob->abilities;
        break;
	case 13:
	  mob->abilities.dex = parm;
	  mob->tmpabilities = mob->abilities;
        break;
	case 14:
	  mob->abilities.con = parm;
	  mob->tmpabilities = mob->abilities;
        break;
	case 15:
	  mob->abilities.str_add = parm;
	  mob->tmpabilities = mob->abilities;
        break;
	default:
	{
          send_to_char("Usage: pset <name> <att> <val>\n\r",ch);
          send_to_char("att: align, exp, sex, race, hit, mhit\n\r",ch);
          send_to_char("     tohit, bank, gold, prac,\n\r",ch); 
          send_to_char("     str,int,wis,dex,con,stradd,\n\r",ch); 
	};
      }
}

do_give_priv(struct char_data *ch, char *argument, int cmd)
{
  char field[20], name[20], parmstr[50];
  char buf[256];
  int index;
  struct char_data *mob;
  int parm, parm2;
  char *pset_list[] = 
  {
    "privs",
    "force",
    "trans",
    "shutdown",
    "load",
    "restore",
    "restore_a",
    "stat",
    "switch",
    "reroll",
    "snoop",
    "string",
    "builder",
    "pretitle",
    "whod",
    "system",
    "logs",
    "debug",
    "goto",
    "at",
    '\0'
  };

  char tmp[80];
  if (IS_NPC(ch))
     return;

  if(strcmp("cyric",GET_NAME(ch)) || IS_NOT_SET(GET_PRIV(ch),PRIV_GIVE_PRIV))
    return;

  argument = one_argument(argument, name);
  argument = one_argument(argument, field);
  strncpy(tmp,argument,79);
  argument = one_argument(argument, parmstr);

  if ((mob = get_char_vis(ch, name)) == NULL) 
  {
    send_to_char("I don't see them here? \n\r\n\r",ch);
    send_to_char("Usage: priv <name> <att> <1/0>\n\r",ch);
    for(index=0;pset_list[index];index++)
    {
      sprintf(buf,"\t%s\n\r",pset_list[index]);
      send_to_char(buf,ch);
    }
    return;
  }

  for(index=0;pset_list[index];index++)
    if(!strcmp(field,pset_list[index]))
    {
      parm2 = sscanf(parmstr,"%d",&parm);
      if(!parm2)
      {
	send_to_char("You must also supply a 1 or 0\n\r",ch);
	return;
      }
      break;
    }

      switch(index)
      {
        case 0:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_GIVE_PRIV);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_GIVE_PRIV);
        break;
	case 1:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_FORCE);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_FORCE);
        break;
	case 2:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_TRANS);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_TRANS);
        break;
	case 3:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_SHUTDOWN);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_SHUTDOWN);
	break;
        case 4:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_LOAD_PURGE);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_LOAD_PURGE);
        break;
        case 5:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_RESTORE);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_RESTORE);
        break;
	case 6:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_RESTORE_A);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_RESTORE_A);
	break;
	case 7:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_STAT);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_STAT);
	break;
	case 8:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_SWITCH);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_SWITCH);
	break;
	case 9:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_SWITCH);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_SWITCH);
	break;
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_REROLL_ADVANCE_PSET);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_REROLL_ADVANCE_PSET);
        break;
	case 11:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_SNOOP);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_SNOOP);
        break;
	case 12:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_STRING_TITLE);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_STRING_TITLE);
        break;
	case 13:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_BUILDER);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_BUILDER);
        break;
	case 14:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_PRETITLE);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_PRETITLE);
        break;
	case 15:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_WHOD);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_WHOD);
        break;
	case 16:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_SYSTEM);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_SYSTEM);
        break;
	case 17:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_LOGS);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_LOGS);
        break;
	case 18:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_DEBUG);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_DEBUG);
        break;
	case 19:
	  if(parm)
            SET_BIT(GET_PRIV(mob),PRIV_GOTO_AT);
          else
	    REMOVE_BIT(GET_PRIV(mob),PRIV_GOTO_AT);
        break;

	default:
	{
	  send_to_char("You wrote it, you should know how to use it.\n",ch);
	};
      }
}

void do_shutdow(struct char_data *ch, char *argument, int cmd)
{
if(DEBUG) dlog("do_shutdow");
  send_to_char("If you want to shut something down - say so!\n\r", ch);
}

void do_shutdown(struct char_data *ch, char *argument, int cmd)
{
  extern int shutdown, reboot;
  char buf[100], arg[MAX_INPUT_LENGTH];

  if(DEBUG) dlog("do_shutdown");
  if (IS_NPC(ch))
    return;

  one_argument(argument, arg);

  if (!*arg) {
    sprintf(buf, "Shutdown by %s.", GET_NAME(ch) );
    send_to_all(buf);
    log(buf);
    shutdown = 1;
  } else if (!str_cmp(arg, "reboot")) {
    sprintf(buf, "Reboot by %s.", GET_NAME(ch));
    send_to_all(buf);
    log(buf);
    shutdown = reboot = 1;
  } else
      send_to_char("Go shut down someone your own size.\n\r", ch);
}


void do_snoop(struct char_data *ch, char *argument, int cmd)
{
  static char arg[MAX_STRING_LENGTH];
  struct char_data *victim;
if(DEBUG) dlog("do_snoop");  
  if (!ch->desc)
    return;
  
  if (IS_NPC(ch))
    return;
  
  only_argument(argument, arg);
  
  if(!*arg) {
    send_to_char("Snoop who ?\n\r",ch);
    return;
  }
  
  if(!(victim=get_char_vis(ch, arg))) {
    send_to_char("No such person around.\n\r",ch);
    return;
  }
  
  if(!victim->desc) {
    send_to_char("There's no link.. nothing to snoop.\n\r",ch);
    return;
  }
  if(victim == ch)  {
    send_to_char("Ok, you just snoop yourself.\n\r",ch);
    if(ch->desc->snoop.snooping) {
      if (ch->desc->snoop.snooping->desc)
  ch->desc->snoop.snooping->desc->snoop.snoop_by = 0;
      else {
  char buf[MAX_STRING_LENGTH];
  sprintf(buf, "caught %s snooping %s who didn't have a descriptor!",
    ch->player.name, ch->desc->snoop.snooping->player.name);
  log(buf);
      }
      ch->desc->snoop.snooping = 0;
    }
    return;
  }
  
  if(victim->desc->snoop.snoop_by) {
    send_to_char("Busy already. \n\r",ch);
    return;
  }
  
  if (GetMaxLevel(victim)>=GetMaxLevel(ch)) {
    send_to_char("You failed.\n\r",ch);
    return;
  }
  
  send_to_char("Ok. \n\r",ch);
  
  if(ch->desc->snoop.snooping)
    if (ch->desc->snoop.snooping->desc)
      ch->desc->snoop.snooping->desc->snoop.snoop_by = 0;
  
  ch->desc->snoop.snooping = victim;
  victim->desc->snoop.snoop_by = ch;
  return;
}



void do_switch(struct char_data *ch, char *argument, int cmd)
{
  static char arg[80];
  struct char_data *victim;
if(DEBUG) dlog("do_switch");  
  if (IS_NPC(ch))
    return;
  
  only_argument(argument, arg);
  
  if (!*arg)  {
    send_to_char("Switch with who?\n\r", ch);
  } else  {
    if (!(victim = get_char(arg)))
      send_to_char("They aren't here.\n\r", ch);
    else    {
      if (ch == victim)   {
  send_to_char("He he he... We are jolly funny today, eh?\n\r", ch);
  return;
      }
      
      if (!ch->desc || ch->desc->snoop.snoop_by || ch->desc->snoop.snooping)
  {
    send_to_char("Mixing snoop & switch is bad for your health.\n\r", ch);
    return;
  }
      
      if(victim->desc || (!IS_NPC(victim)))       {
  send_to_char(
         "You can't do that, the body is already in use!\n\r",ch);
      }  else {
  send_to_char("Ok.\n\r", ch);
  
  ch->desc->character = victim;
  ch->desc->original = ch;
  
  victim->desc = ch->desc;
  ch->desc = 0;
      }
    }
  }
}

void do_return(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *mob, *per;
if(DEBUG) dlog("do_return");  
  if(!ch->desc)
    return;
  
  if(!ch->desc->original)   { 
    send_to_char("Huh? Talk sense I cant understand you\n\r", ch);
    return;
  } else  {
    send_to_char("You return to your original body.\n\r",ch);
    
    if (IS_SET(ch->specials.act, ACT_POLYSELF) && cmd) {
      mob = ch;
      per = ch->desc->original;
      
      act("$n turns liquid, and reforms as $N", TRUE, mob, 0, per, TO_ROOM);

      char_from_room(per);
      char_to_room(per,mob->in_room);

      SwitchStuff(mob, per);
    }
    
    ch->desc->character = ch->desc->original;
    ch->desc->original = 0;
    
    ch->desc->character->desc = ch->desc; 
    ch->desc = 0;
    
    if (IS_SET(ch->specials.act, ACT_POLYSELF) && cmd) {
      extract_char(mob);
    }   
  }
}

void do_force(struct char_data *ch, char *argument, int cmd)
{
  struct descriptor_data *i;
  struct char_data *vict;
  extern struct char_data *board_kludge_char;
  char name[100], to_force[100],buf[100]; 
if(DEBUG) dlog("do_force");  
  if (IS_NPC(ch) && (cmd != 0))
    return;
  
  half_chop(argument, name, to_force);
  
  if (!*name || !*to_force)
    send_to_char("Who do you wish to force to do what?\n\r", ch);
  else if (str_cmp("all", name)) {
    if (!(vict = get_char_vis(ch, name)))
      send_to_char("No-one by that name here..\n\r", ch);
    else {
      if ((GetMaxLevel(ch) <= GetMaxLevel(vict)) && (!IS_NPC(vict)))
  send_to_char("Oh no you don't!!\n\r", ch);
      else {
  sprintf(buf, "$n has forced you to '%s'.", to_force);
  act(buf, FALSE, ch, 0, vict, TO_VICT);
  send_to_char("Ok.\n\r", ch);
  command_interpreter(vict, to_force);
      }
    }
  } else { /* force all */
    for (i = descriptor_list; i; i = i->next)
      if (i->character != ch && !i->connected && i->character != board_kludge_char) {
        vict = i->character;
        if ((GetMaxLevel(ch) <= GetMaxLevel(vict)) &&
            (!IS_NPC(vict)))
    send_to_char("Oh no you don't!!\n\r", ch);
  else {
    sprintf(buf, "$n has forced you to '%s'.", to_force);
    act(buf, FALSE, ch, 0, vict, TO_VICT);
    command_interpreter(vict, to_force);
  }
      }
    send_to_char("Ok.\n\r", ch);
  }
}

void do_load(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *mob;
  struct obj_data *obj;
  char type[100], num[100];
  int number;
  
  extern int top_of_mobt;
  extern int top_of_objt;
if(DEBUG) dlog("do_load");  
  if (IS_NPC(ch))
    return;
  
  argument = one_argument(argument, type);
  
  only_argument(argument, num);
  if (isdigit(*num))
    number = atoi(num);
  else
    number = -1;
  
  if (is_abbrev(type, "mobile"))  {
    if (number<0) {
      for (number = 0; number<=top_of_mobt; number++)
  if (isname(num, mob_index[number].name))
    break;
      if (number>top_of_mobt)
  number = -1;
    } else {
      number = real_mobile(number);
    }
    if ( number<0 || number>top_of_mobt) {
      send_to_char("There is no such monster.\n\r", ch);
      return;
    }
    mob = read_mobile(number, REAL);
    char_to_room(mob, ch->in_room);
    
    act("$n makes a quaint, magical gesture with one hand.", TRUE, ch,
  0, 0, TO_ROOM);
    act("$n has summoned $N from the ether!", FALSE, ch, 0, mob, TO_ROOM);
    act("You bring forth $N from the the cosmic ether.", FALSE, ch, 0, mob, TO_CHAR);
    
  } else if (is_abbrev(type, "object")) {
    if (number<0) {
      for (number = 0; number<=top_of_objt; number++)
  if (isname(num, obj_index[number].name))
    break;
      if (number>top_of_objt)
  number = -1;
    } else {
      number = real_object(number);
    }
    if ( number<0 || number>top_of_mobt) {
      send_to_char("There is no such object.\n\r", ch);
      return;
    }
    
    obj = read_object(number, REAL);
    obj_to_char(obj, ch);
    act("$n makes a strange magical gesture.", TRUE, ch, 0, 0, TO_ROOM);
    act("$n has created $p!", FALSE, ch, obj, 0, TO_ROOM);
    act("You now have $p.", FALSE, ch, obj, 0, TO_CHAR);
  }
  else
  if (is_abbrev(type, "room")) 
  {
    int start, end;
    
    if (GetMaxLevel(ch) < CREATOR)
      return;
    
    switch (sscanf(num, "%d %d", &start, &end)) {
    case 2: /* we got both numbers */
      RoomLoad(ch, start, end);
      break;
    case 1: /* we only got one, load it */
      RoomLoad(ch, start, start);
      break;
    default:
      send_to_char("Load? Fine!  Load we must, But what?\n\r", ch);
      break;
    }
  } else {
    send_to_char("Usage: load (object|mobile) (number|name)\n\r"
     "       load room start [end]\n\r", ch);
  }
}

static void purge_one_room(int rnum, struct room_data *rp, int *range)
{
  struct char_data  *ch;
  struct obj_data *obj;
if(DEBUG) dlog("purge_one_room");
  if (rnum==0 || rnum < range[0] || rnum > range[1])
    return;

  while (rp->people) 
  {
    ch = rp->people;
    send_to_char("The gods strike down from the heavens making the", ch);
    send_to_char("world tremble.  All that's left is the Void.", ch);
    char_from_room(ch);
    char_to_room(ch, 0);  /* send character to the void */
    do_look(ch, "", 15);
    act("$n tumbles into the Void.", TRUE, ch, 0, 0, TO_ROOM);
  }

  while (rp->contents) {
    obj = rp->contents;
    obj_from_room(obj);
    obj_to_room(obj, 0);  /* send item to the void */
  }
  completely_cleanout_room(rp); /* clear out the pointers */
  hash_remove(&room_db, rnum);  /* remove it from the database */
}


/* clean a room of all mobiles and objects */
void do_purge(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *vict, *next_v;
  struct obj_data *obj, *next_o;
  
  char name[100];
if(DEBUG) dlog("do_purge");  
  if (IS_NPC(ch)) return;
  
  only_argument(argument, name);
  
  if (*name) {  /* argument supplied. destroy single object or char */
      if (vict = get_char_room_vis(ch, name)) {
  if ((!IS_NPC(vict) || IS_SET(vict->specials.act, ACT_POLYSELF)) && 
      (GetMaxLevel(ch)<IMPLEMENTOR)) {
    send_to_char("I'm sorry, Dave.  I can't let you do that.\n\r", ch);
    return;
  }
  
  act("$n disintegrates $N.", FALSE, ch, 0, vict, TO_NOTVICT);
  
  if (IS_NPC(vict) || (!IS_SET(ch->specials.act, ACT_POLYSELF))) {
    extract_char(vict);
  } else {
    if (vict->desc) {
      close_socket(vict->desc);
      vict->desc = 0;
      extract_char(vict);
    } else {
      extract_char(vict);
    }
  }
      } else if (obj = get_obj_in_list_vis
             (ch, name, real_roomp(ch->in_room)->contents)) {
  act("$n destroys $p.", FALSE, ch, obj, 0, TO_ROOM);
  extract_obj(obj);
      } else  {
  argument = one_argument(argument, name);
  if (0==str_cmp("room", name)) 
  {
    int range[2];
    if (GetMaxLevel(ch)<IMPLEMENTOR) 
    {
      send_to_char("I'm sorry, Dave.  I can't let you do that.\n\r", ch);
      return;
    }
    argument = one_argument(argument,name);
    if (!isdigit(*name)) 
    {
      send_to_char("purge room start [end]",ch);
      return;
    }
    range[0] = atoi(name);
    argument = one_argument(argument,name);
    if (isdigit(*name))
      range[1] = atoi(name);
    else
      range[1] = range[0];
    
    if (range[0]==0 || range[1]==0) {
      send_to_char("usage: purge room start [end]\n\r", ch);
      return;
    }
    hash_iterate(&room_db,purge_one_room,range);
  } else {
    send_to_char("I don't see that here.\n\r", ch);
    return;
  }
      }
      
      send_to_char("Ok.\n\r", ch);
    }  else {   /* no argument. clean out the room */
      if (GetMaxLevel(ch) < DEMIGOD)
  return;
      if (IS_NPC(ch)) {
  send_to_char("You would only kill yourself..\n\r", ch);
  return;
      }
      
      act("$n gestures, the world erupts around you in flames!", 
    FALSE, ch, 0, 0, TO_ROOM);
      send_to_room("The world seems a little cleaner.\n\r", ch->in_room);

      for (vict = real_roomp(ch->in_room)->people; vict; vict = next_v) {
  next_v = vict->next_in_room;
  if (IS_NPC(vict) && (!IS_SET(vict->specials.act, ACT_POLYSELF)))
    extract_char(vict);
      }
      
      for (obj = real_roomp(ch->in_room)->contents; obj; obj = next_o) {
  next_o = obj->next_content;
  extract_obj(obj);
      }
    }
}



/* Give pointers to the five abilities */
void roll_abilities(struct char_data *ch)
{
  int i, j, k, temp;
  ubyte table[5];
  ubyte rools[4];
if(DEBUG) dlog("roll_abilities");
  for(i=0; i<5; table[i++]=0)  ;

  for(i=0; i<5; i++) {

    for(j=0; j<4; j++)
      rools[j] = number(1,6);
    
    temp = rools[0]+rools[1]+rools[2]+rools[3] -
               MIN(rools[0], MIN(rools[1], MIN(rools[2],rools[3])));

    for(k=0; k<5; k++)
      if (table[k] < temp)
        SWITCH(temp, table[k]);
  }

  ch->abilities.str_add = 0;

  switch (ch->player.class) {
    case CLASS_MAGIC_USER: {
      ch->abilities.intel = table[0];
      ch->abilities.wis = table[1];
      ch->abilities.dex = table[2];
      ch->abilities.str = table[3];
      ch->abilities.con = table[4];
    } break;
    case CLASS_DRUID: {
      ch->abilities.wis = table[0];
      ch->abilities.intel = table[1];
      ch->abilities.str = table[2];
      ch->abilities.dex = table[3];
      ch->abilities.con = table[4];
    } break;
    case CLASS_CLERIC: {
      ch->abilities.wis = table[0];
      ch->abilities.intel = table[1];
      ch->abilities.str = table[2];
      ch->abilities.dex = table[3];
      ch->abilities.con = table[4];
    } break;
    case CLASS_CLERIC+CLASS_MAGIC_USER: {
      ch->abilities.wis = table[0];
      ch->abilities.intel = table[1];
      ch->abilities.dex = table[2];
      ch->abilities.str = table[3];
      ch->abilities.con = table[4];
    } break;
    case CLASS_THIEF: {
      ch->abilities.dex = table[0];
      ch->abilities.intel = table[1];
      ch->abilities.str = table[2];
      ch->abilities.con = table[3];
      ch->abilities.wis = table[4];
    } break;
    case CLASS_THIEF+CLASS_MAGIC_USER: {
      ch->abilities.intel = table[0];
      ch->abilities.dex = table[1];
      ch->abilities.str = table[2];
      ch->abilities.con = table[3];
      ch->abilities.wis = table[4];
    } break;
    case CLASS_THIEF+CLASS_CLERIC: {
      ch->abilities.wis = table[0];
      ch->abilities.dex = table[1];
      ch->abilities.intel = table[2];
      ch->abilities.str = table[3];
      ch->abilities.con = table[4];
    } break;
    case CLASS_THIEF+CLASS_MAGIC_USER+CLASS_CLERIC : {
      ch->abilities.wis = table[0];
      ch->abilities.intel = table[1];
      ch->abilities.dex = table[2];
      ch->abilities.str = table[3];
      ch->abilities.con = table[4];
    } break;
    case CLASS_RANGER: {
      ch->abilities.str = table[0];
      ch->abilities.con = table[3];
      ch->abilities.dex = table[2];
      ch->abilities.wis = table[1];
      ch->abilities.intel = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = 0;
    } break; 
    case CLASS_WARRIOR: {
      ch->abilities.str = table[0];
      ch->abilities.con = table[1];
      ch->abilities.dex = table[2];
      ch->abilities.wis = table[3];
      ch->abilities.intel = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = number(0,100);
    } break;
      case CLASS_WARRIOR+CLASS_MAGIC_USER: {
      ch->abilities.str = table[0];
      ch->abilities.intel = table[1];
      ch->abilities.con = table[2];
      ch->abilities.dex = table[3];
      ch->abilities.wis = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = 0;
      } break;
      case CLASS_WARRIOR+CLASS_CLERIC: {
      ch->abilities.wis = table[0];
      ch->abilities.str = table[1];
      ch->abilities.intel = table[2];
      ch->abilities.con = table[3];
      ch->abilities.dex = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = 0;
      } break;
      case CLASS_WARRIOR+CLASS_THIEF: {
      ch->abilities.str = table[0];
      ch->abilities.dex = table[1];
      ch->abilities.con = table[2];
      ch->abilities.intel = table[3];
      ch->abilities.wis = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = 0;
      } break;
      case CLASS_WARRIOR+CLASS_MAGIC_USER+CLASS_CLERIC: {
      ch->abilities.wis = table[0];
      ch->abilities.str = table[1];
      ch->abilities.intel = table[2];
      ch->abilities.dex = table[3];
      ch->abilities.con = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = 0;
      } break;
      case CLASS_WARRIOR+CLASS_MAGIC_USER+CLASS_THIEF: {
      ch->abilities.intel = table[0];
      ch->abilities.str = table[1];
      ch->abilities.dex = table[2];
      ch->abilities.con = table[3];
      ch->abilities.wis = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = 0;
      } break;
      case CLASS_WARRIOR+CLASS_THIEF+CLASS_CLERIC: {
      ch->abilities.str = table[0];
      ch->abilities.wis = table[1];
      ch->abilities.dex = table[2];
      ch->abilities.intel = table[3];
      ch->abilities.con = table[4];
      if (ch->abilities.str == 18)
        ch->abilities.str_add = 0;
      } break;
    default:
      log("Error on class (do_reroll)");
  }

  switch(GET_RACE(ch))
  {
    case RACE_ELVEN:
      ch->abilities.intel +=1;
      break;
    case RACE_DWARF:
      ch->abilities.con +=1;
      ch->abilities.intel -=1;
      break;
    case RACE_HALFLING:
      ch->abilities.dex +=1;
      ch->abilities.con -=1;
      break;
    case RACE_GNOME:
      ch->abilities.wis +=1;
      ch->abilities.dex -=1;
      break;
  }

  if(ch->abilities.str > 18)
    ch->abilities.str = 18;
  if(ch->abilities.dex > 18)
    ch->abilities.dex = 18;
  if(ch->abilities.intel > 18)
    ch->abilities.intel = 18;
  if(ch->abilities.wis > 18)
    ch->abilities.wis = 18;
  if(ch->abilities.con > 18)
    ch->abilities.con = 18;

  ch->tmpabilities = ch->abilities;
}

void do_start(struct char_data *ch)
{
  int i, r_num;
  struct obj_data *obj;

  extern struct dex_skill_type dex_app_skill[];
  void advance_level(struct char_data *ch, int i);
if(DEBUG) dlog("do_start");
  StartLevels(ch);
  GET_EXP(ch) = 1;
  set_title(ch);
  roll_abilities(ch);

  ch->points.max_hit=20;

/* Heafty Bread */
  if ((r_num = real_object(5016)) >= 0) {
    obj = read_object(r_num, REAL);
    obj_to_char(obj,ch);   /* */ 
    obj = read_object(r_num, REAL);
    obj_to_char(obj,ch); 
  }

/* Bottle of Water */
  if ((r_num = real_object(3003)) >= 0) 
  {
    obj = read_object(r_num, REAL);
    obj_to_char(obj,ch); 
    obj = read_object(r_num, REAL);
    obj_to_char(obj,ch); 
   }

/* Club */
  if ((r_num = real_object(3048)) >= 0 ) 
  {
    obj = read_object(r_num,REAL);
    obj_to_char(obj,ch); 
  }

/* Map of Shylar */
  if((r_num = real_object(3050)) >= 0)
  {
    obj = read_object(r_num,REAL);
    obj_to_char(obj,ch);
  }

  if (IS_SET(ch->player.class, CLASS_RANGER)) 
  {
    ch->skills[SKILL_HUNT].learned = 1;
    ch->skills[SKILL_DISARM].learned = 1;
  }

  if (IS_SET(ch->player.class, CLASS_THIEF)) 
  {
    ch->skills[SKILL_SNEAK].learned = 1;
    ch->skills[SKILL_HIDE].learned =  1;
    ch->skills[SKILL_STEAL].learned = 1;
    ch->skills[SKILL_BACKSTAB].learned = 1;
    ch->skills[SKILL_PICK_LOCK].learned = 1;
  } 

  GET_HIT(ch) = GET_MAX_HIT(ch);
  GET_MANA(ch) = GET_MAX_MANA(ch);
  ch->points.max_move = GET_MAX_MOVE(ch);
  GET_MOVE(ch) = GET_MAX_MOVE(ch);

  GET_COND(ch,THIRST) = 24;
  GET_COND(ch,FULL) = 24;
  GET_COND(ch,DRUNK) = 0;

  ch->player.time.played = 0;
  ch->player.time.logon = time(0);
}

void do_advance(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *victim;
  char name[100], level[100], class[100];
  int adv, newlevel, lin_class;

  void gain_exp(struct char_data *ch, int gain);
if(DEBUG) dlog("do_advance");
  if (IS_NPC(ch))
    return;

  argument = one_argument(argument, name);

  if (*name)  
  {
    if (!(victim = get_char_room_vis(ch, name)))    
    {
      send_to_char("That player is not here.\n\r", ch);
      return;
    }
  }
  else 
  {
    send_to_char("Advance who?\n\r", ch);
    return;
  }

  if (IS_NPC(victim)) {
    send_to_char("NO! Not on NPC's.\n\r", ch);
    return;
  }

  argument = one_argument(argument, class);

  if (!*class) {
    send_to_char("Classes you may suply: [ M C W T R ]\n\r",ch);
    return;
  }

  switch(*class) {
  case 'M':
  case 'm':
    lin_class = MAGE_LEVEL_IND;
    break;

  case 'T':
  case 't':
    lin_class = THIEF_LEVEL_IND;
    break;
    
  case 'W':
  case 'w':
  case 'F':
  case 'f':
    lin_class = WARRIOR_LEVEL_IND;
    break;
    
  case 'C':
  case 'c':
  case 'P':
  case 'p':
    lin_class = CLERIC_LEVEL_IND;
    break;

  case 'R':
  case 'r':
          lin_class = RANGER_LEVEL_IND;
    break;

  case 'D':
  case 'd':
    lin_class = DRUID_LEVEL_IND;
    break;

  default:
    send_to_char("Classes you may use [ M C W T R ]\n\r", ch);
    return;
    break;

  }
  
  argument = one_argument(argument, level);

  if (GET_LEVEL(victim, lin_class) == 0)
    adv = 1;
  else 
  if (!*level)
  {
    send_to_char("You must supply a level number.\n\r", ch);
    return;
  }
  else
  {
    if (!isdigit(*level))   
    {
      send_to_char("Third argument must be a positive integer.\n\r",ch);
      return;
    }

    if ((newlevel = atoi(level)) < GET_LEVEL(victim, lin_class)) 
    {
      send_to_char("Can't dimish a players status (yet).\n\r", ch);
      return;
    }

    adv = newlevel - GET_LEVEL(victim,lin_class);
  }

  if(((adv + GET_LEVEL(victim, lin_class))>1) &&
      (GetMaxLevel(ch) < IMPLEMENTOR))
  {
    send_to_char("Thou art not godly enough.\n\r", ch);
    return;
  }

  if ((adv + GET_LEVEL(victim, lin_class)) > IMPLEMENTOR) {
    send_to_char("Implementor is the highest possible level.\n\r", ch);
    return;
  }

  if (((adv + GET_LEVEL(victim, lin_class)) < 1)&&
      ((adv + GET_LEVEL(victim, lin_class)) != 1))
  {
    send_to_char("1 is the lowest possible level.\n\r", ch);
    return;
  }

  send_to_char("You feel generous.\n\r", ch);
  act("$n makes some strange gestures.\n\rA strange feeling comes upon you,"
      "\n\rLike a giant hand, light comes down from\n\rabove, grabbing your "
      "body, that begins\n\rto pulse with coloured lights from inside.\n\rYo"
      "ur head seems to be filled with daemons\n\rfrom another plane as your"
      " body dissolves\n\rinto the elements of time and space itself.\n\rSudde"
      "nly a silent explosion of light snaps\n\ryou back to reality. You fee"
      "l slightly\n\rdifferent.",FALSE,ch,0,victim,TO_VICT);
  
  if (GET_LEVEL(victim, lin_class) == 0) 
  {
    do_start(victim);
  }
  else
  {
    if (GET_LEVEL(victim, lin_class) < IMPLEMENTOR) 
    {
      int amount_needed,amount_have;

      amount_needed=titles[lin_class][GET_LEVEL(victim,lin_class)+adv].exp+1;
      amount_have = GET_EXP(victim);
      gain_exp_regardless(victim,amount_needed-amount_have,lin_class);
      send_to_char("Character is now advanced.\n\r", ch);
    } 
    else
    {
      send_to_char("Some idiot just tried to advance your level.\n\r", victim);
      send_to_char("IMPOSSIBLE! IDIOTIC!\n\r", ch);
    }
  }
}

void do_reroll(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *victim;
  char buf[100];
if(DEBUG) dlog("do_reroll");  
  if (IS_NPC(ch))
    return;
  
  only_argument(argument,buf);
  if (!*buf)
    send_to_char("Who do you wish to reroll?\n\r",ch);
  else
    if(!(victim = get_char(buf)))
      send_to_char("No-one by that name in the world.\n\r",ch);
    else {
      send_to_char("Rerolled...\n\r", ch);
      roll_abilities(victim);
    }
}

void do_restore_all(struct char_data *ch,char *arg,int cmd)
{
  struct descriptor_data *i;
  extern struct char_data *board_kludge_char;
  struct char_data *vict;

  void do_restore(struct char_data *ch,char *arg,int cmd);
if(DEBUG) dlog("do_restore_all");
  for (i = descriptor_list; i; i = i->next)
    if(i->character!=ch&&!i->connected && i->character != board_kludge_char) 
    {
      vict = i->character;
      do_restore(ch,GET_NAME(vict),0);
    }
}

void do_restore(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *victim;
  char buf[100];
  int i;
  
  void update_pos( struct char_data *victim );
  
if(DEBUG) dlog("do_restore");  
  only_argument(argument,buf);
  if (!*buf)
    send_to_char("Who do you wish to restore?\n\r",ch);
  else
    if(!(victim = get_char(buf)))
      send_to_char("No-one by that name in the world.\n\r",ch);
    else 
    {
      GET_MANA(victim) = GET_MAX_MANA(victim);
      if(!affected_by_spell(victim,SPELL_AID))
      {
        GET_HIT(victim) = GET_MAX_HIT(victim);
      }
      else
      {
	if(GET_HIT(victim) < GET_MAX_HIT(victim))
	  GET_HIT(victim) = GET_MAX_HIT(victim);
      }

      GET_MOVE(victim) = GET_MAX_MOVE(victim);
      
      if (IS_NPC(victim))
        return;
      
      if (GetMaxLevel(victim) < LOW_IMMORTAL) {
        GET_COND(victim,THIRST) = 24;
  GET_COND(victim,FULL) = 24;
      } else {
  GET_COND(victim,THIRST) = -1;
  GET_COND(victim,FULL) = -1;
      }
      
      if (GetMaxLevel(victim) >= CREATOR) {
  for (i = 0; i < MAX_SKILLS; i++) {
    victim->skills[i].learned = 100;
    victim->skills[i].recognise = TRUE;
  }
  
  if (GetMaxLevel(victim) >= SILLYLORD) {
    victim->abilities.str_add = 100;
    victim->abilities.intel = 25;
    victim->abilities.wis = 25;
    victim->abilities.dex = 25;
    victim->abilities.str = 25;
    victim->abilities.con = 25;
  }
  victim->tmpabilities = victim->abilities;
  
      }
      update_pos( victim );
      send_to_char("Done.\n\r", ch);
      act("You have been fully healed by $N!", FALSE, victim, 0, ch, TO_CHAR);
    }
}

do_show_logs(struct char_data *ch,char *argument, int cmd)
{
if(DEBUG) dlog("do_show_logs");
  if(IS_SET(ch->specials.act,PLR_LOGS))
  {
    send_to_char("You will no longer recieve the logs to your screen.\n\r",ch);
    REMOVE_BIT(ch->specials.act,PLR_LOGS);
    return;
  }
  else
  {
    send_to_char("You WILL recieve the logs to your screen.\n\r",ch);
    SET_BIT(ch->specials.act,PLR_LOGS);
    return;
  }
}

do_noshout(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *vict;
  struct obj_data *dummy;
  char buf[MAX_INPUT_LENGTH];
  
  if(DEBUG) dlog("do_noshout");
  if (IS_NPC(ch))
    return;
  
  only_argument(argument, buf);
  
  if (!*buf)
    if (IS_SET(ch->specials.act, PLR_NOSHOUT))    {
      send_to_char("You can now hear shouts again.\n\r", ch);
      REMOVE_BIT(ch->specials.act, PLR_NOSHOUT);
    }   else    {
      send_to_char("From now on, you won't hear shouts.\n\r", ch);
      SET_BIT(ch->specials.act, PLR_NOSHOUT);
    }
  else if (!generic_find(argument, FIND_CHAR_WORLD, ch, &vict, &dummy))
    send_to_char("Couldn't find any such creature.\n\r", ch);
  else if (IS_NPC(vict))
    send_to_char("Can't do that to a beast.\n\r", ch);
  else if (GetMaxLevel(vict) >= GetMaxLevel(ch))
    act("$E might object to that.. better not.", 0, ch, 0, vict, TO_CHAR);
  else if (IS_SET(vict->specials.act, PLR_NOSHOUT) &&
     (GetMaxLevel(ch) >= SAINT))  {
    send_to_char("You can shout again.\n\r", vict);
    send_to_char("NOSHOUT removed.\n\r", ch);
    REMOVE_BIT(vict->specials.act, PLR_NOSHOUT);
  } else if (GetMaxLevel(ch) >= SAINT)  {
    send_to_char("The gods take away your ability to shout!\n\r", vict);
    send_to_char("NOSHOUT set.\n\r", ch);
    SET_BIT(vict->specials.act, PLR_NOSHOUT);
  } else {
    send_to_char("Sorry, you can't do that\n\r",ch);
  }
}

void do_pager(struct char_data *ch,char *arg,int cmd)
{
if(DEBUG) dlog("do_pager");
  if(IS_SET(ch->specials.act,PLR_PAGER))
  {
    send_to_char("You stop using the Wiley Pager.\n\r",ch);
    REMOVE_BIT(ch->specials.act,PLR_PAGER);
  }
  else
  {
    send_to_char("You now USE the Wiley Pager.\n\r",ch);
    SET_BIT(ch->specials.act,PLR_PAGER);
  }
}

void do_nohassle(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *vict;
  struct obj_data *dummy;
  char buf[MAX_INPUT_LENGTH];
  
  if(DEBUG) dlog("do_nohassle");
  if (IS_NPC(ch))
    return;
  
  only_argument(argument, buf);
  
  if (!*buf)
    if (IS_SET(ch->specials.act, PLR_NOHASSLE))
      {
  send_to_char("You can now be hassled again.\n\r", ch);
  REMOVE_BIT(ch->specials.act, PLR_NOHASSLE);
      }
    else
      {
  send_to_char("From now on, you won't be hassled.\n\r", ch);
  SET_BIT(ch->specials.act, PLR_NOHASSLE);
      }
  else if (!generic_find(argument, FIND_CHAR_WORLD, ch, &vict, &dummy))
    send_to_char("Couldn't find any such creature.\n\r", ch);
  else if (IS_NPC(vict))
    send_to_char("Can't do that to a beast.\n\r", ch);
  else if (GetMaxLevel(vict) > GetMaxLevel(ch))
    act("$E might object to that.. better not.", 0, ch, 0, vict, TO_CHAR);
  else
    send_to_char("The implementor won't let you set this on mortals...\n\r",ch);
}

void do_stealth(struct char_data *ch, char *argument, int cmd)
{
  struct char_data *vict;
  struct obj_data *dummy;
  char buf[MAX_INPUT_LENGTH];
if(DEBUG) dlog("do_stealth");  
  if (IS_NPC(ch))
    return;
  
  only_argument(argument, buf);
  
  if (!*buf)
    if (IS_SET(ch->specials.act, PLR_STEALTH))
      {
  send_to_char("STEALTH mode OFF.\n\r", ch);
  REMOVE_BIT(ch->specials.act, PLR_STEALTH);
      }
    else
      {
  send_to_char("STEALTH mode ON.\n\r", ch);
  SET_BIT(ch->specials.act, PLR_STEALTH);
      }
  else if (!generic_find(argument, FIND_CHAR_WORLD, ch, &vict, &dummy))
    send_to_char("Couldn't find any such creature.\n\r", ch);
  else if (IS_NPC(vict))
    send_to_char("Can't do that to a beast.\n\r", ch);
  else if (GetMaxLevel(vict) > GetMaxLevel(ch))
    act("$E might object to that.. better not.", 0, ch, 0, vict, TO_CHAR);
  else
    send_to_char("The implementor won't let you set this on mortals...\n\r",ch);

}

static print_room(int rnum, struct room_data *rp, struct string_block *sb)
{
  char  buf[MAX_STRING_LENGTH];
  int dink,bits, scan;
  extern char *room_bits[];
  extern char *sector_types[];
if(DEBUG) dlog("print_room");
  sprintf(buf, "%5d %4d %-12s %s", rp->number, rnum,
    sector_types[rp->sector_type], rp->name);
  strcat(buf, " [");

  dink=0;
  for (bits=rp->room_flags, scan=0; bits; scan++) {
    if (bits & (1<<scan)) {
      if (dink)
  strcat(buf, " ");
      strcat(buf, room_bits[scan]);
      dink=1;
      bits ^= (1<<scan);
    }
  }
  strcat(buf, "]\n\r");

  append_to_string_block(sb, buf);
}

static void print_death_room(int rnum, struct room_data *rp, struct string_block *sb)
{
  if(DEBUG) dlog("print_death_room");
  if (rp && rp->room_flags&DEATH)
    print_room(rnum, rp, sb);
}

static void print_private_room(int rnum, struct room_data *rp, struct string_block *sb)
{
  if(DEBUG) dlog("print_private_room");
  if (rp && rp->room_flags&PRIVATE)
    print_room(rnum, rp, sb);
}

struct show_room_zone_struct {
  int blank;
  int startblank, lastblank;
  int bottom, top;
  struct string_block *sb;
};

static void show_room_zone(int rnum, struct room_data *rp,
         struct show_room_zone_struct *srzs)
{
  char buf[MAX_STRING_LENGTH];

  if(DEBUG) dlog("show_room_zone");
  if (!rp || rp->number<srzs->bottom || rp->number>srzs->top)
    return; /* optimize later*/
  
  if (srzs->blank && (srzs->lastblank+1 != rp->number) ) {
    sprintf(buf, "rooms %d-%d are blank\n\r", srzs->startblank, srzs->lastblank);
    append_to_string_block(srzs->sb, buf);
    srzs->blank = 0;
  }
  if (1==sscanf(rp->name, "%d", &srzs->lastblank) &&
      srzs->lastblank==rp->number) {
    if (!srzs->blank) {
      srzs->startblank = srzs->lastblank;
      srzs->blank = 1;
    }
    return;
  } else if (srzs->blank) {
    sprintf(buf, "rooms %d-%d are blank\n\r", srzs->startblank, srzs->lastblank);
    append_to_string_block(srzs->sb, buf);
    srzs->blank = 0;
  }
  
  print_room(rnum, rp, srzs->sb);
}

void do_show(struct char_data *ch, char *argument, int cmd)
{
  int zone;
  char buf[MAX_STRING_LENGTH], zonenum[MAX_INPUT_LENGTH];
  struct index_data *which_i;
  int bottom, top, topi;
  struct string_block sb;
if(DEBUG) dlog("do_show");  
  if (IS_NPC(ch)) return;
  
  argument = one_argument(argument, buf);
  init_string_block(&sb);

  if (is_abbrev(buf, "zones")) 
  {
    struct zone_data  *zd;
    int bottom=0;
    append_to_string_block(&sb,
      "# Zone   name                                lifespan age     rooms     reset\n\r");

    for(zone=0; zone<=top_of_zone_table; zone++) 
    {
      char  *mode;

      zd = zone_table+zone;
      switch(zd->reset_mode) {
      case 0: mode = "never";      break;
      case 1: mode = "ifempty";    break;
      case 2: mode = "always";     break;
      default: mode = "!unknown!"; break;
      }
      sprintf(buf,"%4d %-40s %4dm %4dm %6d-%-6d %s\n\r", zone, zd->name,
        zd->lifespan, zd->age, bottom, zd->top, mode);
      append_to_string_block(&sb, buf);
      bottom = zd->top+1;
    }
    
    
  }
  else
  if (is_abbrev(buf, "objects") &&
      (which_i=obj_index,topi=top_of_objt) ||
      is_abbrev(buf, "mobiles") &&
      (which_i=mob_index,topi=top_of_mobt) ) 
  {
    int   objn;
    struct index_data *oi;
    only_argument(argument, zonenum);
    zone = -1;
    if (1==sscanf(zonenum,"%i", &zone)&&(zone<0 || zone>top_of_zone_table )) 
    {
      append_to_string_block(&sb, "That is not a valid zone_number\n\r");
      return;
    }

    if (zone>=0) 
    {
      bottom = zone ? (zone_table[zone-1].top+1) : 0;
      top = zone_table[zone].top;
    }
    
    append_to_string_block(&sb, "VNUM  rnum count names\n\r");
    for (objn=0; objn<=topi; objn++) 
    {
      oi = which_i + objn;
      if (zone>=0 &&
	 (oi->virtual<bottom ||
	  oi->virtual>top) ||
          zone<0 &&
	  !isname(zonenum, oi->name))
      continue; /* optimize later*/
      sprintf(buf,"%5d %4d %3d  %s\n\r",oi->virtual,objn,oi->number,oi->name);
      append_to_string_block(&sb, buf);
    }
  }
  else 
  if (is_abbrev(buf, "rooms"))
  {
    only_argument(argument, zonenum);
    append_to_string_block(&sb, "VNUM  rnum type         name [BITS]\n\r");
    if (is_abbrev(zonenum, "death")) 
    {
      hash_iterate(&room_db, print_death_room, &sb);
    }
    else
    if (is_abbrev(zonenum, "private")) 
    {
      hash_iterate(&room_db, print_private_room, &sb);
    }
    else
    if (1!=sscanf(zonenum,"%i", &zone) || zone<0 || zone>top_of_zone_table) 
    {
      append_to_string_block(&sb, "I need a zone number with this command\n\r");
    }
    else 
    {
      struct show_room_zone_struct  srzs;
      srzs.bottom = zone ? (zone_table[zone-1].top+1) : 0;
      srzs.top = zone_table[zone].top;
      srzs.blank = 0;
      srzs.sb = &sb;
      hash_iterate(&room_db, show_room_zone, &srzs);
      if (srzs.blank)
      {
        sprintf(buf,"rooms %d-%d are blank\n\r",srzs.startblank,srzs.lastblank);
        append_to_string_block(&sb, buf);
        srzs.blank = 0;
      }
    }
  }
  else
  {
    append_to_string_block(&sb,"Usage:\n\r"
     "  show zones\n\r"
     "  show (objects|mobiles) (zone#|name)\n\r"
     "  show rooms (zone#|death|private)\n\r", ch);
  }
  page_string_block(&sb,ch);
  destroy_string_block(&sb);
}


void do_debug(struct char_data *ch, char *argument, int cmd)
{
  char  arg[MAX_INPUT_LENGTH];
  int i;

  i=0;
  one_argument(argument, arg);
  i = atoi(arg);

  if (i<0 || i>2) 
  {
    send_to_char("valid values are 0, 1, 2\n\r", ch);
  } 
  else
  {
    switch(i)
    {
      case 0:
        DEBUG = 0;
	DEBUG2 = 0;
	break;
      case 1:
	DEBUG = 1;
	DEBUG2 = 0;
	break;
      case 2:
	DEBUG = 0;
	DEBUG2 = 1;
	break;
    }

    sprintf(arg, "debug level set to %d\n\r", i);
    send_to_char(arg, ch);
  }
}

void do_invis(struct char_data *ch, char *argument, int cmd)
{
  char  buf[MAX_STRING_LENGTH];
  int level;
 if(DEBUG) dlog("do_invis"); 
  if (scan_number(argument, &level)) 
  {
    if (level<=0) 
      level=0;
    else 
    {
      if (level>GetMaxLevel(ch))
      {
	send_to_char("Sorry, you cant invis that high yet!\n\r",ch);
	return;
      }
    }
    ch->invis_level = level;
    sprintf(buf,"Invis level set to %d.\n\r", level);
    send_to_char(buf, ch);
  }
  else
  {
    if (ch->invis_level>0) 
    {
      ch->invis_level = 0;
      send_to_char("You are now totally VISIBLE.\n\r",ch);
    }
    else
    {
      ch->invis_level = GetMaxLevel(ch) - 1;
      sprintf(buf,"You are now invisible to level %d.\n\r",GetMaxLevel(ch) - 1);
      send_to_char(buf,ch);
    }
  }
}
